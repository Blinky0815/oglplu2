//  File implement/eglplus/enum/value_defs.inl
//
//  Automatically generated file, DO NOT modify manually.
//  Edit the enumeration source files in 'source/enums/eglplus'
//  or the 'source/enums/make_enum.py' script instead.
//
//  Copyright Matus Chochlik.
//  Distributed under the Boost Software License, Version 1.0.
//  See accompanying file LICENSE_1_0.txt or copy at
//   http://www.boost.org/LICENSE_1_0.txt
//

namespace eglplus {

#ifdef EGL_ALPHA_MASK_SIZE
const enum_value<
	EGLenum,
	EGL_ALPHA_MASK_SIZE,
	mp_list<eglplus::config_attrib>
> enum_value::alpha_mask_size;
#endif

#ifdef EGL_ALPHA_SIZE
const enum_value<
	EGLenum,
	EGL_ALPHA_SIZE,
	mp_list<eglplus::config_attrib>
> enum_value::alpha_size;
#endif

#ifdef EGL_BACK_BUFFER
const enum_value<
	EGLenum,
	EGL_BACK_BUFFER,
	mp_list<eglplus::render_buffer>
> enum_value::back_buffer;
#endif

#ifdef EGL_BAD_ACCESS
const enum_value<
	EGLenum,
	EGL_BAD_ACCESS,
	mp_list<eglplus::error_code>
> enum_value::bad_access;
#endif

#ifdef EGL_BAD_ALLOC
const enum_value<
	EGLenum,
	EGL_BAD_ALLOC,
	mp_list<eglplus::error_code>
> enum_value::bad_alloc;
#endif

#ifdef EGL_BAD_ATTRIBUTE
const enum_value<
	EGLenum,
	EGL_BAD_ATTRIBUTE,
	mp_list<eglplus::error_code>
> enum_value::bad_attribute;
#endif

#ifdef EGL_BAD_CONFIG
const enum_value<
	EGLenum,
	EGL_BAD_CONFIG,
	mp_list<eglplus::error_code>
> enum_value::bad_config;
#endif

#ifdef EGL_BAD_CONTEXT
const enum_value<
	EGLenum,
	EGL_BAD_CONTEXT,
	mp_list<eglplus::error_code>
> enum_value::bad_context;
#endif

#ifdef EGL_BAD_CURRENT_SURFACE
const enum_value<
	EGLenum,
	EGL_BAD_CURRENT_SURFACE,
	mp_list<eglplus::error_code>
> enum_value::bad_current_surface;
#endif

#ifdef EGL_BAD_DISPLAY
const enum_value<
	EGLenum,
	EGL_BAD_DISPLAY,
	mp_list<eglplus::error_code>
> enum_value::bad_display;
#endif

#ifdef EGL_BAD_MATCH
const enum_value<
	EGLenum,
	EGL_BAD_MATCH,
	mp_list<eglplus::error_code>
> enum_value::bad_match;
#endif

#ifdef EGL_BAD_NATIVE_PIXMAP
const enum_value<
	EGLenum,
	EGL_BAD_NATIVE_PIXMAP,
	mp_list<eglplus::error_code>
> enum_value::bad_native_pixmap;
#endif

#ifdef EGL_BAD_NATIVE_WINDOW
const enum_value<
	EGLenum,
	EGL_BAD_NATIVE_WINDOW,
	mp_list<eglplus::error_code>
> enum_value::bad_native_window;
#endif

#ifdef EGL_BAD_PARAMETER
const enum_value<
	EGLenum,
	EGL_BAD_PARAMETER,
	mp_list<eglplus::error_code>
> enum_value::bad_parameter;
#endif

#ifdef EGL_BAD_SURFACE
const enum_value<
	EGLenum,
	EGL_BAD_SURFACE,
	mp_list<eglplus::error_code>
> enum_value::bad_surface;
#endif

#ifdef EGL_BIND_TO_TEXTURE_RGB
const enum_value<
	EGLenum,
	EGL_BIND_TO_TEXTURE_RGB,
	mp_list<eglplus::config_attrib>
> enum_value::bind_to_texture_rgb;
#endif

#ifdef EGL_BIND_TO_TEXTURE_RGBA
const enum_value<
	EGLenum,
	EGL_BIND_TO_TEXTURE_RGBA,
	mp_list<eglplus::config_attrib>
> enum_value::bind_to_texture_rgba;
#endif

#ifdef EGL_BLUE_SIZE
const enum_value<
	EGLenum,
	EGL_BLUE_SIZE,
	mp_list<eglplus::config_attrib>
> enum_value::blue_size;
#endif

#ifdef EGL_BUFFER_DESTROYED
const enum_value<
	EGLenum,
	EGL_BUFFER_DESTROYED,
	mp_list<eglplus::swap_behavior>
> enum_value::buffer_destroyed;
#endif

#ifdef EGL_BUFFER_PRESERVED
const enum_value<
	EGLenum,
	EGL_BUFFER_PRESERVED,
	mp_list<eglplus::swap_behavior>
> enum_value::buffer_preserved;
#endif

#ifdef EGL_BUFFER_SIZE
const enum_value<
	EGLenum,
	EGL_BUFFER_SIZE,
	mp_list<eglplus::config_attrib>
> enum_value::buffer_size;
#endif

#ifdef EGL_CLIENT_APIS
const enum_value<
	EGLenum,
	EGL_CLIENT_APIS,
	mp_list<eglplus::string_query>
> enum_value::client_apis;
#endif

#ifdef EGL_COLOR_BUFFER_TYPE
const enum_value<
	EGLenum,
	EGL_COLOR_BUFFER_TYPE,
	mp_list<eglplus::config_attrib>
> enum_value::color_buffer_type;
#endif

#ifdef EGL_CONFIG_CAVEAT
const enum_value<
	EGLenum,
	EGL_CONFIG_CAVEAT,
	mp_list<eglplus::config_attrib>
> enum_value::config_caveat;
#endif

#ifdef EGL_CONFIG_ID
const enum_value<
	EGLenum,
	EGL_CONFIG_ID,
	mp_list<eglplus::config_attrib,eglplus::surface_attrib>
> enum_value::config_id;
#endif

#ifdef EGL_CONFORMANT
const enum_value<
	EGLenum,
	EGL_CONFORMANT,
	mp_list<eglplus::config_attrib>
> enum_value::conformant;
#endif

#ifdef EGL_CONTEXT_FLAGS
const enum_value<
	EGLenum,
	EGL_CONTEXT_FLAGS,
	mp_list<eglplus::context_attrib>
> enum_value::context_flags;
#endif

#ifdef EGL_CONTEXT_LOST
const enum_value<
	EGLenum,
	EGL_CONTEXT_LOST,
	mp_list<eglplus::error_code>
> enum_value::context_lost;
#endif

#ifdef EGL_CONTEXT_MAJOR_VERSION
const enum_value<
	EGLenum,
	EGL_CONTEXT_MAJOR_VERSION,
	mp_list<eglplus::context_attrib>
> enum_value::context_major_version;
#endif

#ifdef EGL_CONTEXT_MINOR_VERSION
const enum_value<
	EGLenum,
	EGL_CONTEXT_MINOR_VERSION,
	mp_list<eglplus::context_attrib>
> enum_value::context_minor_version;
#endif

#ifdef EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT
const enum_value<
	EGLenum,
	EGL_CONTEXT_OPENGL_COMPATIBILITY_PROFILE_BIT,
	mp_list<eglplus::opengl_profile_bit>
> enum_value::context_opengl_compatibility_profile_bit;
#endif

#ifdef EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT
const enum_value<
	EGLenum,
	EGL_CONTEXT_OPENGL_CORE_PROFILE_BIT,
	mp_list<eglplus::opengl_profile_bit>
> enum_value::context_opengl_core_profile_bit;
#endif

#ifdef EGL_CONTEXT_OPENGL_DEBUG_BIT
const enum_value<
	EGLenum,
	EGL_CONTEXT_OPENGL_DEBUG_BIT,
	mp_list<eglplus::context_flag>
> enum_value::context_opengl_debug_bit;
#endif

#ifdef EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT
const enum_value<
	EGLenum,
	EGL_CONTEXT_OPENGL_FORWARD_COMPATIBLE_BIT,
	mp_list<eglplus::context_flag>
> enum_value::context_opengl_forward_compatible_bit;
#endif

#ifdef EGL_CONTEXT_OPENGL_PROFILE_MASK
const enum_value<
	EGLenum,
	EGL_CONTEXT_OPENGL_PROFILE_MASK,
	mp_list<eglplus::context_attrib>
> enum_value::context_opengl_profile_mask;
#endif

#ifdef EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY
const enum_value<
	EGLenum,
	EGL_CONTEXT_OPENGL_RESET_NOTIFICATION_STRATEGY,
	mp_list<eglplus::context_attrib>
> enum_value::context_opengl_reset_notification_strategy;
#endif

#ifdef EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT
const enum_value<
	EGLenum,
	EGL_CONTEXT_OPENGL_ROBUST_ACCESS_BIT,
	mp_list<eglplus::context_flag>
> enum_value::context_opengl_robust_access_bit;
#endif

#ifdef EGL_DEPTH_SIZE
const enum_value<
	EGLenum,
	EGL_DEPTH_SIZE,
	mp_list<eglplus::config_attrib>
> enum_value::depth_size;
#endif

#ifdef EGL_EXTENSIONS
const enum_value<
	EGLenum,
	EGL_EXTENSIONS,
	mp_list<eglplus::string_query>
> enum_value::extensions;
#endif

#ifdef EGL_GL_COLORSPACE
const enum_value<
	EGLenum,
	EGL_GL_COLORSPACE,
	mp_list<eglplus::surface_attrib>
> enum_value::gl_colorspace;
#endif

#ifdef EGL_GL_COLORSPACE_LINEAR
const enum_value<
	EGLenum,
	EGL_GL_COLORSPACE_LINEAR,
	mp_list<eglplus::gl_colorspace>
> enum_value::gl_colorspace_linear;
#endif

#ifdef EGL_GL_COLORSPACE_sRGB
const enum_value<
	EGLenum,
	EGL_GL_COLORSPACE_sRGB,
	mp_list<eglplus::gl_colorspace>
> enum_value::gl_colorspace_srgb;
#endif

#ifdef EGL_GREEN_SIZE
const enum_value<
	EGLenum,
	EGL_GREEN_SIZE,
	mp_list<eglplus::config_attrib>
> enum_value::green_size;
#endif

#ifdef EGL_HEIGHT
const enum_value<
	EGLenum,
	EGL_HEIGHT,
	mp_list<eglplus::surface_attrib>
> enum_value::height;
#endif

#ifdef EGL_HORIZONTAL_RESOLUTION
const enum_value<
	EGLenum,
	EGL_HORIZONTAL_RESOLUTION,
	mp_list<eglplus::surface_attrib>
> enum_value::horizontal_resolution;
#endif

#ifdef EGL_LARGEST_PBUFFER
const enum_value<
	EGLenum,
	EGL_LARGEST_PBUFFER,
	mp_list<eglplus::surface_attrib>
> enum_value::largest_pbuffer;
#endif

#ifdef EGL_LEVEL
const enum_value<
	EGLenum,
	EGL_LEVEL,
	mp_list<eglplus::config_attrib>
> enum_value::level;
#endif

#ifdef EGL_LOSE_CONTEXT_ON_RESET
const enum_value<
	EGLenum,
	EGL_LOSE_CONTEXT_ON_RESET,
	mp_list<eglplus::opengl_rns>
> enum_value::lose_context_on_reset;
#endif

#ifdef EGL_LUMINANCE_BUFFER
const enum_value<
	EGLenum,
	EGL_LUMINANCE_BUFFER,
	mp_list<eglplus::color_buffer_type>
> enum_value::luminance_buffer;
#endif

#ifdef EGL_LUMINANCE_SIZE
const enum_value<
	EGLenum,
	EGL_LUMINANCE_SIZE,
	mp_list<eglplus::config_attrib>
> enum_value::luminance_size;
#endif

#ifdef EGL_MAX_PBUFFER_HEIGHT
const enum_value<
	EGLenum,
	EGL_MAX_PBUFFER_HEIGHT,
	mp_list<eglplus::config_attrib>
> enum_value::max_pbuffer_height;
#endif

#ifdef EGL_MAX_PBUFFER_PIXELS
const enum_value<
	EGLenum,
	EGL_MAX_PBUFFER_PIXELS,
	mp_list<eglplus::config_attrib>
> enum_value::max_pbuffer_pixels;
#endif

#ifdef EGL_MAX_PBUFFER_WIDTH
const enum_value<
	EGLenum,
	EGL_MAX_PBUFFER_WIDTH,
	mp_list<eglplus::config_attrib>
> enum_value::max_pbuffer_width;
#endif

#ifdef EGL_MAX_SWAP_INTERVAL
const enum_value<
	EGLenum,
	EGL_MAX_SWAP_INTERVAL,
	mp_list<eglplus::config_attrib>
> enum_value::max_swap_interval;
#endif

#ifdef EGL_MIN_SWAP_INTERVAL
const enum_value<
	EGLenum,
	EGL_MIN_SWAP_INTERVAL,
	mp_list<eglplus::config_attrib>
> enum_value::min_swap_interval;
#endif

#ifdef EGL_MIPMAP_LEVEL
const enum_value<
	EGLenum,
	EGL_MIPMAP_LEVEL,
	mp_list<eglplus::surface_attrib>
> enum_value::mipmap_level;
#endif

#ifdef EGL_MIPMAP_TEXTURE
const enum_value<
	EGLenum,
	EGL_MIPMAP_TEXTURE,
	mp_list<eglplus::surface_attrib>
> enum_value::mipmap_texture;
#endif

#ifdef EGL_MULTISAMPLE_RESOLVE
const enum_value<
	EGLenum,
	EGL_MULTISAMPLE_RESOLVE,
	mp_list<eglplus::surface_attrib>
> enum_value::multisample_resolve;
#endif

#ifdef EGL_MULTISAMPLE_RESOLVE_BOX
const enum_value<
	EGLenum,
	EGL_MULTISAMPLE_RESOLVE_BOX,
	mp_list<eglplus::multisample_resolve>
> enum_value::multisample_resolve_box;
#endif

#ifdef EGL_MULTISAMPLE_RESOLVE_BOX_BIT
const enum_value<
	EGLenum,
	EGL_MULTISAMPLE_RESOLVE_BOX_BIT,
	mp_list<eglplus::surface_type_bit>
> enum_value::multisample_resolve_box_bit;
#endif

#ifdef EGL_MULTISAMPLE_RESOLVE_DEFAULT
const enum_value<
	EGLenum,
	EGL_MULTISAMPLE_RESOLVE_DEFAULT,
	mp_list<eglplus::multisample_resolve>
> enum_value::multisample_resolve_default;
#endif

#ifdef EGL_NATIVE_RENDERABLE
const enum_value<
	EGLenum,
	EGL_NATIVE_RENDERABLE,
	mp_list<eglplus::config_attrib>
> enum_value::native_renderable;
#endif

#ifdef EGL_NATIVE_VISUAL_ID
const enum_value<
	EGLenum,
	EGL_NATIVE_VISUAL_ID,
	mp_list<eglplus::config_attrib>
> enum_value::native_visual_id;
#endif

#ifdef EGL_NATIVE_VISUAL_TYPE
const enum_value<
	EGLenum,
	EGL_NATIVE_VISUAL_TYPE,
	mp_list<eglplus::config_attrib>
> enum_value::native_visual_type;
#endif

#ifdef EGL_NO_RESET_NOTIFICATION
const enum_value<
	EGLenum,
	EGL_NO_RESET_NOTIFICATION,
	mp_list<eglplus::opengl_rns>
> enum_value::no_reset_notification;
#endif

#ifdef EGL_NO_TEXTURE
const enum_value<
	EGLenum,
	EGL_NO_TEXTURE,
	mp_list<eglplus::texture_target,eglplus::texture_format>
> enum_value::no_texture;
#endif

#ifdef EGL_NON_CONFORMANT_CONFIG
const enum_value<
	EGLenum,
	EGL_NON_CONFORMANT_CONFIG,
	mp_list<eglplus::config_caveat>
> enum_value::non_conformant_config;
#endif

#ifdef EGL_NONE
const enum_value<
	EGLenum,
	EGL_NONE,
	mp_list<eglplus::rendering_api,eglplus::config_caveat,eglplus::transparent_type>
> enum_value::none;
#endif

#ifdef EGL_NOT_INITIALIZED
const enum_value<
	EGLenum,
	EGL_NOT_INITIALIZED,
	mp_list<eglplus::error_code>
> enum_value::not_initialized;
#endif

#ifdef EGL_OPENGL_API
const enum_value<
	EGLenum,
	EGL_OPENGL_API,
	mp_list<eglplus::rendering_api>
> enum_value::opengl_api;
#endif

#ifdef EGL_OPENGL_BIT
const enum_value<
	EGLenum,
	EGL_OPENGL_BIT,
	mp_list<eglplus::renderable_type_bit>
> enum_value::opengl_bit;
#endif

#ifdef EGL_OPENGL_ES2_BIT
const enum_value<
	EGLenum,
	EGL_OPENGL_ES2_BIT,
	mp_list<eglplus::renderable_type_bit>
> enum_value::opengl_es2_bit;
#endif

#ifdef EGL_OPENGL_ES3_BIT
const enum_value<
	EGLenum,
	EGL_OPENGL_ES3_BIT,
	mp_list<eglplus::renderable_type_bit>
> enum_value::opengl_es3_bit;
#endif

#ifdef EGL_OPENGL_ES_API
const enum_value<
	EGLenum,
	EGL_OPENGL_ES_API,
	mp_list<eglplus::rendering_api>
> enum_value::opengl_es_api;
#endif

#ifdef EGL_OPENGL_ES_BIT
const enum_value<
	EGLenum,
	EGL_OPENGL_ES_BIT,
	mp_list<eglplus::renderable_type_bit>
> enum_value::opengl_es_bit;
#endif

#ifdef EGL_OPENVG_API
const enum_value<
	EGLenum,
	EGL_OPENVG_API,
	mp_list<eglplus::rendering_api>
> enum_value::openvg_api;
#endif

#ifdef EGL_OPENVG_BIT
const enum_value<
	EGLenum,
	EGL_OPENVG_BIT,
	mp_list<eglplus::renderable_type_bit>
> enum_value::openvg_bit;
#endif

#ifdef EGL_PBUFFER_BIT
const enum_value<
	EGLenum,
	EGL_PBUFFER_BIT,
	mp_list<eglplus::surface_type_bit>
> enum_value::pbuffer_bit;
#endif

#ifdef EGL_PIXEL_ASPECT_RATIO
const enum_value<
	EGLenum,
	EGL_PIXEL_ASPECT_RATIO,
	mp_list<eglplus::surface_attrib>
> enum_value::pixel_aspect_ratio;
#endif

#ifdef EGL_PIXMAP_BIT
const enum_value<
	EGLenum,
	EGL_PIXMAP_BIT,
	mp_list<eglplus::surface_type_bit>
> enum_value::pixmap_bit;
#endif

#ifdef EGL_RED_SIZE
const enum_value<
	EGLenum,
	EGL_RED_SIZE,
	mp_list<eglplus::config_attrib>
> enum_value::red_size;
#endif

#ifdef EGL_RENDER_BUFFER
const enum_value<
	EGLenum,
	EGL_RENDER_BUFFER,
	mp_list<eglplus::surface_attrib>
> enum_value::render_buffer;
#endif

#ifdef EGL_RENDERABLE_TYPE
const enum_value<
	EGLenum,
	EGL_RENDERABLE_TYPE,
	mp_list<eglplus::config_attrib>
> enum_value::renderable_type;
#endif

#ifdef EGL_RGB_BUFFER
const enum_value<
	EGLenum,
	EGL_RGB_BUFFER,
	mp_list<eglplus::color_buffer_type>
> enum_value::rgb_buffer;
#endif

#ifdef EGL_SAMPLE_BUFFERS
const enum_value<
	EGLenum,
	EGL_SAMPLE_BUFFERS,
	mp_list<eglplus::config_attrib>
> enum_value::sample_buffers;
#endif

#ifdef EGL_SAMPLES
const enum_value<
	EGLenum,
	EGL_SAMPLES,
	mp_list<eglplus::config_attrib>
> enum_value::samples;
#endif

#ifdef EGL_SINGLE_BUFFER
const enum_value<
	EGLenum,
	EGL_SINGLE_BUFFER,
	mp_list<eglplus::render_buffer>
> enum_value::single_buffer;
#endif

#ifdef EGL_SLOW_CONFIG
const enum_value<
	EGLenum,
	EGL_SLOW_CONFIG,
	mp_list<eglplus::config_caveat>
> enum_value::slow_config;
#endif

#ifdef EGL_STENCIL_SIZE
const enum_value<
	EGLenum,
	EGL_STENCIL_SIZE,
	mp_list<eglplus::config_attrib>
> enum_value::stencil_size;
#endif

#ifdef EGL_SURFACE_TYPE
const enum_value<
	EGLenum,
	EGL_SURFACE_TYPE,
	mp_list<eglplus::config_attrib>
> enum_value::surface_type;
#endif

#ifdef EGL_SWAP_BEHAVIOR
const enum_value<
	EGLenum,
	EGL_SWAP_BEHAVIOR,
	mp_list<eglplus::surface_attrib>
> enum_value::swap_behavior;
#endif

#ifdef EGL_SWAP_BEHAVIOR_PRESERVED_BIT
const enum_value<
	EGLenum,
	EGL_SWAP_BEHAVIOR_PRESERVED_BIT,
	mp_list<eglplus::surface_type_bit>
> enum_value::swap_behavior_preserved_bit;
#endif

#ifdef EGL_TEXTURE_2D
const enum_value<
	EGLenum,
	EGL_TEXTURE_2D,
	mp_list<eglplus::texture_target>
> enum_value::texture_2d;
#endif

#ifdef EGL_TEXTURE_FORMAT
const enum_value<
	EGLenum,
	EGL_TEXTURE_FORMAT,
	mp_list<eglplus::surface_attrib>
> enum_value::texture_format;
#endif

#ifdef EGL_TEXTURE_RGB
const enum_value<
	EGLenum,
	EGL_TEXTURE_RGB,
	mp_list<eglplus::texture_format>
> enum_value::texture_rgb;
#endif

#ifdef EGL_TEXTURE_RGBA
const enum_value<
	EGLenum,
	EGL_TEXTURE_RGBA,
	mp_list<eglplus::texture_format>
> enum_value::texture_rgba;
#endif

#ifdef EGL_TEXTURE_TARGET
const enum_value<
	EGLenum,
	EGL_TEXTURE_TARGET,
	mp_list<eglplus::surface_attrib>
> enum_value::texture_target;
#endif

#ifdef EGL_TRANSPARENT_BLUE_VALUE
const enum_value<
	EGLenum,
	EGL_TRANSPARENT_BLUE_VALUE,
	mp_list<eglplus::config_attrib>
> enum_value::transparent_blue_value;
#endif

#ifdef EGL_TRANSPARENT_GREEN_VALUE
const enum_value<
	EGLenum,
	EGL_TRANSPARENT_GREEN_VALUE,
	mp_list<eglplus::config_attrib>
> enum_value::transparent_green_value;
#endif

#ifdef EGL_TRANSPARENT_RED_VALUE
const enum_value<
	EGLenum,
	EGL_TRANSPARENT_RED_VALUE,
	mp_list<eglplus::config_attrib>
> enum_value::transparent_red_value;
#endif

#ifdef EGL_TRANSPARENT_RGB
const enum_value<
	EGLenum,
	EGL_TRANSPARENT_RGB,
	mp_list<eglplus::transparent_type>
> enum_value::transparent_rgb;
#endif

#ifdef EGL_TRANSPARENT_TYPE
const enum_value<
	EGLenum,
	EGL_TRANSPARENT_TYPE,
	mp_list<eglplus::config_attrib>
> enum_value::transparent_type;
#endif

#ifdef EGL_VENDOR
const enum_value<
	EGLenum,
	EGL_VENDOR,
	mp_list<eglplus::string_query>
> enum_value::vendor;
#endif

#ifdef EGL_VERSION
const enum_value<
	EGLenum,
	EGL_VERSION,
	mp_list<eglplus::string_query>
> enum_value::version;
#endif

#ifdef EGL_VERTICAL_RESOLUTION
const enum_value<
	EGLenum,
	EGL_VERTICAL_RESOLUTION,
	mp_list<eglplus::surface_attrib>
> enum_value::vertical_resolution;
#endif

#ifdef EGL_VG_ALPHA_FORMAT
const enum_value<
	EGLenum,
	EGL_VG_ALPHA_FORMAT,
	mp_list<eglplus::surface_attrib>
> enum_value::vg_alpha_format;
#endif

#ifdef EGL_VG_ALPHA_FORMAT_NONPRE
const enum_value<
	EGLenum,
	EGL_VG_ALPHA_FORMAT_NONPRE,
	mp_list<eglplus::vg_alpha_format>
> enum_value::vg_alpha_format_nonpre;
#endif

#ifdef EGL_VG_ALPHA_FORMAT_PRE
const enum_value<
	EGLenum,
	EGL_VG_ALPHA_FORMAT_PRE,
	mp_list<eglplus::vg_alpha_format>
> enum_value::vg_alpha_format_pre;
#endif

#ifdef EGL_VG_ALPHA_FORMAT_PRE_BIT
const enum_value<
	EGLenum,
	EGL_VG_ALPHA_FORMAT_PRE_BIT,
	mp_list<eglplus::surface_type_bit>
> enum_value::vg_alpha_format_pre_bit;
#endif

#ifdef EGL_VG_COLORSPACE
const enum_value<
	EGLenum,
	EGL_VG_COLORSPACE,
	mp_list<eglplus::surface_attrib>
> enum_value::vg_colorspace;
#endif

#ifdef EGL_VG_COLORSPACE_LINEAR
const enum_value<
	EGLenum,
	EGL_VG_COLORSPACE_LINEAR,
	mp_list<eglplus::vg_colorspace>
> enum_value::vg_colorspace_linear;
#endif

#ifdef EGL_VG_COLORSPACE_LINEAR_BIT
const enum_value<
	EGLenum,
	EGL_VG_COLORSPACE_LINEAR_BIT,
	mp_list<eglplus::surface_type_bit>
> enum_value::vg_colorspace_linear_bit;
#endif

#ifdef EGL_VG_COLORSPACE_sRGB
const enum_value<
	EGLenum,
	EGL_VG_COLORSPACE_sRGB,
	mp_list<eglplus::vg_colorspace>
> enum_value::vg_colorspace_srgb;
#endif

#ifdef EGL_WIDTH
const enum_value<
	EGLenum,
	EGL_WIDTH,
	mp_list<eglplus::surface_attrib>
> enum_value::width;
#endif

#ifdef EGL_WINDOW_BIT
const enum_value<
	EGLenum,
	EGL_WINDOW_BIT,
	mp_list<eglplus::surface_type_bit>
> enum_value::window_bit;
#endif

} // namespace eglplus

#endif // include guard
