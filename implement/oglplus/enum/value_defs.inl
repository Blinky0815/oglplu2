//  File implement/oglplus/enum/value_defs.inl
//
//  Automatically generated file, DO NOT modify manually.
//  Edit the enumeration source files in 'source/enums/oglplus'
//  or the 'source/enums/make_enum.py' script instead.
//
//  Copyright Matus Chochlik.
//  Distributed under the Boost Software License, Version 1.0.
//  See accompanying file LICENSE_1_0.txt or copy at
//   http://www.boost.org/LICENSE_1_0.txt
//

namespace oglplus {

#ifdef GL_ACCUM_ADJACENT_PAIRS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_list_mode_nv>
> enum_values::accum_adjacent_pairs_nv;
#endif

#ifdef GL_ACTIVE_ATTRIBUTE_MAX_LENGTH
const enum_value<
	GLenum,
	mp_list<oglplus::program_parameter>
> enum_values::active_attribute_max_length;
#endif

#ifdef GL_ACTIVE_ATTRIBUTES
const enum_value<
	GLenum,
	mp_list<oglplus::program_parameter>
> enum_values::active_attributes;
#endif

#ifdef GL_ACTIVE_PROGRAM
const enum_value<
	GLenum,
	mp_list<oglplus::program_pipeline_parameter>
> enum_values::active_program;
#endif

#ifdef GL_ACTIVE_UNIFORM_MAX_LENGTH
const enum_value<
	GLenum,
	mp_list<oglplus::program_parameter>
> enum_values::active_uniform_max_length;
#endif

#ifdef GL_ACTIVE_UNIFORMS
const enum_value<
	GLenum,
	mp_list<oglplus::program_parameter>
> enum_values::active_uniforms;
#endif

#ifdef GL_ACTIVE_VARIABLES
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::active_variables;
#endif

#ifdef GL_ADJACENT_PAIRS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_list_mode_nv>
> enum_values::adjacent_pairs_nv;
#endif

#ifdef GL_AFFINE_2D_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_transform_type_nv>
> enum_values::affine_2d_nv;
#endif

#ifdef GL_AFFINE_3D_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_transform_type_nv>
> enum_values::affine_3d_nv;
#endif

#ifdef GL_ALIASED_LINE_WIDTH_RANGE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::aliased_line_width_range;
#endif

#ifdef GL_ALL_BARRIER_BITS
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::all_barrier_bits;
#endif

#ifdef GL_ALL_SHADER_BITS
const enum_value<
	GLbitfield,
	mp_list<oglplus::program_pipeline_stage>
> enum_values::all_shader_bits;
#endif

#ifdef GL_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::path_color_format_nv,oglplus::texture_swizzle_mode>
> enum_values::alpha;
#endif

#ifdef GL_ALPHA_REF_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::alpha_ref_command_nv;
#endif

#ifdef GL_ALREADY_SIGNALED
const enum_value<
	GLenum,
	mp_list<oglplus::sync_wait_result>
> enum_values::already_signaled;
#endif

#ifdef GL_ALWAYS
const enum_value<
	GLenum,
	mp_list<oglplus::compare_function>
> enum_values::always;
#endif

#ifdef GL_AND
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::and_;
#endif

#ifdef GL_AND_INVERTED
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::and_inverted;
#endif

#ifdef GL_AND_REVERSE
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::and_reverse;
#endif

#ifdef GL_ANY_SAMPLES_PASSED
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::any_samples_passed;
#endif

#ifdef GL_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::arc_to_nv;
#endif

#ifdef GL_ARRAY_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::array_buffer;
#endif

#ifdef GL_ARRAY_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::array_buffer_binding;
#endif

#ifdef GL_ARRAY_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::array_size;
#endif

#ifdef GL_ARRAY_STRIDE
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::array_stride;
#endif

#ifdef GL_ATOMIC_COUNTER_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::atomic_counter_barrier_bit;
#endif

#ifdef GL_ATOMIC_COUNTER_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_indexed_target,oglplus::buffer_target,oglplus::program_interface>
> enum_values::atomic_counter_buffer;
#endif

#ifdef GL_ATOMIC_COUNTER_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::atomic_counter_buffer_binding;
#endif

#ifdef GL_ATOMIC_COUNTER_BUFFER_INDEX
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::atomic_counter_buffer_index;
#endif

#ifdef GL_ATTACHED_SHADERS
const enum_value<
	GLenum,
	mp_list<oglplus::program_parameter>
> enum_values::attached_shaders;
#endif

#ifdef GL_ATTRIBUTE_ADDRESS_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::attribute_address_command_nv;
#endif

#ifdef GL_BACK
const enum_value<
	GLenum,
	mp_list<oglplus::color_buffer,oglplus::single_face,oglplus::face>
> enum_values::back;
#endif

#ifdef GL_BACK_LEFT
const enum_value<
	GLenum,
	mp_list<oglplus::color_buffer>
> enum_values::back_left;
#endif

#ifdef GL_BACK_RIGHT
const enum_value<
	GLenum,
	mp_list<oglplus::color_buffer>
> enum_values::back_right;
#endif

#ifdef GL_BEVEL_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_join_style_nv>
> enum_values::bevel_nv;
#endif

#ifdef GL_BGR
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::bgr;
#endif

#ifdef GL_BGR_INTEGER
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::bgr_integer;
#endif

#ifdef GL_BGRA
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::bgra;
#endif

#ifdef GL_BGRA_INTEGER
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::bgra_integer;
#endif

#ifdef GL_BLEND
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::blend;
#endif

#ifdef GL_BLEND_ADVANCED_COHERENT_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::blend_advanced_coherent;
#endif

#ifdef GL_BLEND_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::blend_color;
#endif

#ifdef GL_BLEND_COLOR_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::blend_color_command_nv;
#endif

#ifdef GL_BLEND_DST_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::blend_dst_alpha;
#endif

#ifdef GL_BLEND_DST_RGB
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::blend_dst_rgb;
#endif

#ifdef GL_BLEND_EQUATION_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::blend_equation_alpha;
#endif

#ifdef GL_BLEND_EQUATION_RGB
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::blend_equation_rgb;
#endif

#ifdef GL_BLEND_SRC_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::blend_src_alpha;
#endif

#ifdef GL_BLEND_SRC_RGB
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::blend_src_rgb;
#endif

#ifdef GL_BLOCK_INDEX
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::block_index;
#endif

#ifdef GL_BLUE
const enum_value<
	GLenum,
	mp_list<oglplus::texture_swizzle_mode,oglplus::pixel_data_format>
> enum_values::blue;
#endif

#ifdef GL_BLUE_INTEGER
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::blue_integer;
#endif

#ifdef GL_BOLD_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_font_style_nv>
> enum_values::bold_bit_nv;
#endif

#ifdef GL_BOOL
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::bool_;
#endif

#ifdef GL_BOOL_VEC2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::bool_vec2;
#endif

#ifdef GL_BOOL_VEC3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::bool_vec3;
#endif

#ifdef GL_BOOL_VEC4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::bool_vec4;
#endif

#ifdef GL_BOUNDING_BOX_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_stroke_cover_mode_nv,oglplus::path_fill_cover_mode_nv>
> enum_values::bounding_box_nv;
#endif

#ifdef GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_stroke_cover_mode_nv,oglplus::path_fill_cover_mode_nv>
> enum_values::bounding_box_of_bounding_boxes_nv;
#endif

#ifdef GL_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::object_type>
> enum_values::buffer;
#endif

#ifdef GL_BUFFER_ACCESS
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_parameter>
> enum_values::buffer_access;
#endif

#ifdef GL_BUFFER_ACCESS_FLAGS
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_parameter>
> enum_values::buffer_access_flags;
#endif

#ifdef GL_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property,oglplus::binding_query>
> enum_values::buffer_binding;
#endif

#ifdef GL_BUFFER_DATA_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::buffer_data_size;
#endif

#ifdef GL_BUFFER_IMMUTABLE_STORAGE
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_parameter>
> enum_values::buffer_immutable_storage;
#endif

#ifdef GL_BUFFER_MAP_LENGTH
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_parameter>
> enum_values::buffer_map_length;
#endif

#ifdef GL_BUFFER_MAP_OFFSET
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_parameter>
> enum_values::buffer_map_offset;
#endif

#ifdef GL_BUFFER_MAPPED
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_parameter>
> enum_values::buffer_mapped;
#endif

#ifdef GL_BUFFER_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_parameter>
> enum_values::buffer_size;
#endif

#ifdef GL_BUFFER_STORAGE_FLAGS
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_parameter>
> enum_values::buffer_storage_flags;
#endif

#ifdef GL_BUFFER_UPDATE_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::buffer_update_barrier_bit;
#endif

#ifdef GL_BUFFER_USAGE
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_parameter>
> enum_values::buffer_usage;
#endif

#ifdef GL_BUFFER_VARIABLE
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::buffer_variable;
#endif

#ifdef GL_BYTE
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type,oglplus::data_type>
> enum_values::byte_;
#endif

#ifdef GL_CCW
const enum_value<
	GLenum,
	mp_list<oglplus::face_orientation>
> enum_values::ccw;
#endif

#ifdef GL_CIRCULAR_CCW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::circular_ccw_arc_to_nv;
#endif

#ifdef GL_CIRCULAR_CW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::circular_cw_arc_to_nv;
#endif

#ifdef GL_CIRCULAR_TANGENT_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::circular_tangent_arc_to_nv;
#endif

#ifdef GL_CLAMP_TO_BORDER
const enum_value<
	GLenum,
	mp_list<oglplus::texture_wrap_mode>
> enum_values::clamp_to_border;
#endif

#ifdef GL_CLAMP_TO_EDGE
const enum_value<
	GLenum,
	mp_list<oglplus::texture_wrap_mode>
> enum_values::clamp_to_edge;
#endif

#ifdef GL_CLEAR
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::clear;
#endif

#ifdef GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::client_mapped_buffer_barrier_bit;
#endif

#ifdef GL_CLIENT_STORAGE_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_storage_bits>
> enum_values::client_storage_bit;
#endif

#ifdef GL_CLIP_DISTANCE0
const enum_value<
	GLenum,
	mp_list<oglplus::indexed_value_base>
> enum_values::clip_distance0;
#endif

#ifdef GL_CLIPPING_INPUT_PRIMITIVES_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::clipping_input_primitives;
#endif

#ifdef GL_CLIPPING_OUTPUT_PRIMITIVES_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::clipping_output_primitives;
#endif

#ifdef GL_CLOSE_PATH_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::close_path_nv;
#endif

#ifdef GL_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_buffer,oglplus::old_matrix_mode>
> enum_values::color;
#endif

#ifdef GL_COLOR_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::color_array_address_nv;
#endif

#ifdef GL_COLOR_ATTACHMENT0
const enum_value<
	GLenum,
	mp_list<oglplus::indexed_value_base>
> enum_values::color_attachment0;
#endif

#ifdef GL_COLOR_BUFFER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_select_bits>
> enum_values::color_buffer_bit;
#endif

#ifdef GL_COLOR_CLEAR_VALUE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::color_clear_value;
#endif

#ifdef GL_COLOR_LOGIC_OP
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::color_logic_op;
#endif

#ifdef GL_COLOR_WRITEMASK
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::color_writemask;
#endif

#ifdef GL_COLORBURN_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::colorburn_khr;
#endif

#ifdef GL_COLORDODGE_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::colordodge_khr;
#endif

#ifdef GL_COMMAND_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::command_barrier_bit;
#endif

#ifdef GL_COMPARE_REF_TO_TEXTURE
const enum_value<
	GLenum,
	mp_list<oglplus::texture_compare_mode>
> enum_values::compare_ref_to_texture;
#endif

#ifdef GL_COMPATIBLE_SUBROUTINES
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::compatible_subroutines;
#endif

#ifdef GL_COMPILE_STATUS
const enum_value<
	GLenum,
	mp_list<oglplus::shader_parameter>
> enum_values::compile_status;
#endif

#ifdef GL_COMPRESSED_R11_EAC
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_r11_eac;
#endif

#ifdef GL_COMPRESSED_RED
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_red;
#endif

#ifdef GL_COMPRESSED_RED_RGTC1
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_red_rgtc1;
#endif

#ifdef GL_COMPRESSED_RG
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rg;
#endif

#ifdef GL_COMPRESSED_RG11_EAC
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rg11_eac;
#endif

#ifdef GL_COMPRESSED_RG_RGTC2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rg_rgtc2;
#endif

#ifdef GL_COMPRESSED_RGB
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rgb;
#endif

#ifdef GL_COMPRESSED_RGB8_ETC2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rgb8_etc2;
#endif

#ifdef GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rgb8_punchthrough_alpha1_etc2;
#endif

#ifdef GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rgb_bptc_signed_float;
#endif

#ifdef GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rgb_bptc_unsigned_float;
#endif

#ifdef GL_COMPRESSED_RGBA
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rgba;
#endif

#ifdef GL_COMPRESSED_RGBA8_ETC2_EAC
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rgba8_etc2_eac;
#endif

#ifdef GL_COMPRESSED_RGBA_BPTC_UNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_rgba_bptc_unorm;
#endif

#ifdef GL_COMPRESSED_SIGNED_R11_EAC
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_signed_r11_eac;
#endif

#ifdef GL_COMPRESSED_SIGNED_RED_RGTC1
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_signed_red_rgtc1;
#endif

#ifdef GL_COMPRESSED_SIGNED_RG11_EAC
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_signed_rg11_eac;
#endif

#ifdef GL_COMPRESSED_SIGNED_RG_RGTC2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_signed_rg_rgtc2;
#endif

#ifdef GL_COMPRESSED_SRGB
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_srgb;
#endif

#ifdef GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_srgb8_alpha8_etc2_eac;
#endif

#ifdef GL_COMPRESSED_SRGB8_ETC2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_srgb8_etc2;
#endif

#ifdef GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_srgb8_punchthrough_alpha1_etc2;
#endif

#ifdef GL_COMPRESSED_SRGB_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_srgb_alpha;
#endif

#ifdef GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::compressed_srgb_alpha_bptc_unorm;
#endif

#ifdef GL_COMPRESSED_TEXTURE_FORMATS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::compressed_texture_formats;
#endif

#ifdef GL_COMPUTE_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::shader_type>
> enum_values::compute_shader;
#endif

#ifdef GL_COMPUTE_SHADER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::program_pipeline_stage>
> enum_values::compute_shader_bit;
#endif

#ifdef GL_COMPUTE_SHADER_INVOCATIONS_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::compute_shader_invocations;
#endif

#ifdef GL_COMPUTE_SUBROUTINE
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::compute_subroutine;
#endif

#ifdef GL_COMPUTE_SUBROUTINE_UNIFORM
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::compute_subroutine_uniform;
#endif

#ifdef GL_CONDITION_SATISFIED
const enum_value<
	GLenum,
	mp_list<oglplus::sync_wait_result>
> enum_values::condition_satisfied;
#endif

#ifdef GL_CONSTANT_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::constant_alpha;
#endif

#ifdef GL_CONSTANT_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::constant_color;
#endif

#ifdef GL_CONTEXT_COMPATIBILITY_PROFILE_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::context_profile_bits>
> enum_values::context_compatibility_profile_bit;
#endif

#ifdef GL_CONTEXT_CORE_PROFILE_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::context_profile_bits>
> enum_values::context_core_profile_bit;
#endif

#ifdef GL_CONTEXT_FLAG_DEBUG_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::context_flag_bits>
> enum_values::context_flag_debug_bit;
#endif

#ifdef GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::context_flag_bits>
> enum_values::context_flag_forward_compatible_bit;
#endif

#ifdef GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB
const enum_value<
	GLbitfield,
	mp_list<oglplus::context_flag_bits>
> enum_values::context_flag_robust_access_bit;
#endif

#ifdef GL_CONTEXT_FLAGS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::context_flags;
#endif

#ifdef GL_CONTEXT_LOST
const enum_value<
	GLenum,
	mp_list<oglplus::error_code>
> enum_values::context_lost;
#endif

#ifdef GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH
const enum_value<
	GLenum,
	mp_list<oglplus::context_release_behavior>
> enum_values::context_release_behavior_flush;
#endif

#ifdef GL_CONVEX_HULL_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_stroke_cover_mode_nv,oglplus::path_fill_cover_mode_nv>
> enum_values::convex_hull_nv;
#endif

#ifdef GL_COPY
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::copy;
#endif

#ifdef GL_COPY_INVERTED
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::copy_inverted;
#endif

#ifdef GL_COPY_READ_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::copy_read_buffer;
#endif

#ifdef GL_COPY_READ_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::copy_read_buffer_binding;
#endif

#ifdef GL_COPY_WRITE_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::copy_write_buffer;
#endif

#ifdef GL_COPY_WRITE_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::copy_write_buffer_binding;
#endif

#ifdef GL_COUNT_DOWN_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_fill_mode_nv>
> enum_values::count_down_nv;
#endif

#ifdef GL_COUNT_UP_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_fill_mode_nv>
> enum_values::count_up_nv;
#endif

#ifdef GL_CUBIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::cubic_curve_to_nv;
#endif

#ifdef GL_CULL_FACE
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::cull_face;
#endif

#ifdef GL_CURRENT_PROGRAM
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::current_program;
#endif

#ifdef GL_CW
const enum_value<
	GLenum,
	mp_list<oglplus::face_orientation>
> enum_values::cw;
#endif

#ifdef GL_DARKEN_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::darken_khr;
#endif

#ifdef GL_DEBUG_GROUP_STACK_DEPTH
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::debug_group_stack_depth;
#endif

#ifdef GL_DEBUG_OUTPUT_SYNCHRONOUS
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::debug_output_synchronous;
#endif

#ifdef GL_DEBUG_SEVERITY_HIGH
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_severity>
> enum_values::debug_severity_high;
#endif

#ifdef GL_DEBUG_SEVERITY_LOW
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_severity>
> enum_values::debug_severity_low;
#endif

#ifdef GL_DEBUG_SEVERITY_MEDIUM
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_severity>
> enum_values::debug_severity_medium;
#endif

#ifdef GL_DEBUG_SEVERITY_NOTIFICATION
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_severity>
> enum_values::debug_severity_notification;
#endif

#ifdef GL_DEBUG_SOURCE_API
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_source>
> enum_values::debug_source_api;
#endif

#ifdef GL_DEBUG_SOURCE_APPLICATION
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_source>
> enum_values::debug_source_application;
#endif

#ifdef GL_DEBUG_SOURCE_OTHER
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_source>
> enum_values::debug_source_other;
#endif

#ifdef GL_DEBUG_SOURCE_SHADER_COMPILER
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_source>
> enum_values::debug_source_shader_compiler;
#endif

#ifdef GL_DEBUG_SOURCE_THIRD_PARTY
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_source>
> enum_values::debug_source_third_party;
#endif

#ifdef GL_DEBUG_SOURCE_WINDOW_SYSTEM
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_source>
> enum_values::debug_source_window_system;
#endif

#ifdef GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_type>
> enum_values::debug_type_deprecated_behavior;
#endif

#ifdef GL_DEBUG_TYPE_ERROR
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_type>
> enum_values::debug_type_error;
#endif

#ifdef GL_DEBUG_TYPE_MARKER
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_type>
> enum_values::debug_type_marker;
#endif

#ifdef GL_DEBUG_TYPE_OTHER
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_type>
> enum_values::debug_type_other;
#endif

#ifdef GL_DEBUG_TYPE_PERFORMANCE
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_type>
> enum_values::debug_type_performance;
#endif

#ifdef GL_DEBUG_TYPE_POP_GROUP
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_type>
> enum_values::debug_type_pop_group;
#endif

#ifdef GL_DEBUG_TYPE_PORTABILITY
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_type>
> enum_values::debug_type_portability;
#endif

#ifdef GL_DEBUG_TYPE_PUSH_GROUP
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_type>
> enum_values::debug_type_push_group;
#endif

#ifdef GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_type>
> enum_values::debug_type_undefined_behavior;
#endif

#ifdef GL_DECR
const enum_value<
	GLenum,
	mp_list<oglplus::stencil_operation>
> enum_values::decr;
#endif

#ifdef GL_DECR_WRAP
const enum_value<
	GLenum,
	mp_list<oglplus::stencil_operation>
> enum_values::decr_wrap;
#endif

#ifdef GL_DELETE_STATUS
const enum_value<
	GLenum,
	mp_list<oglplus::program_parameter,oglplus::shader_parameter>
> enum_values::delete_status;
#endif

#ifdef GL_DEPTH
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_buffer>
> enum_values::depth;
#endif

#ifdef GL_DEPTH24_STENCIL8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::depth24_stencil8;
#endif

#ifdef GL_DEPTH32F_STENCIL8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::depth32f_stencil8;
#endif

#ifdef GL_DEPTH_ATTACHMENT
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_other_attachment>
> enum_values::depth_attachment;
#endif

#ifdef GL_DEPTH_BUFFER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_select_bits>
> enum_values::depth_buffer_bit;
#endif

#ifdef GL_DEPTH_CLEAR_VALUE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::depth_clear_value;
#endif

#ifdef GL_DEPTH_COMPONENT
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format,oglplus::pixel_data_internal_format>
> enum_values::depth_component;
#endif

#ifdef GL_DEPTH_COMPONENT16
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::depth_component16;
#endif

#ifdef GL_DEPTH_COMPONENT24
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::depth_component24;
#endif

#ifdef GL_DEPTH_COMPONENT32
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::depth_component32;
#endif

#ifdef GL_DEPTH_COMPONENT32F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::depth_component32f;
#endif

#ifdef GL_DEPTH_FUNC
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::depth_func;
#endif

#ifdef GL_DEPTH_RANGE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::depth_range;
#endif

#ifdef GL_DEPTH_STENCIL
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_buffer,oglplus::pixel_data_format,oglplus::pixel_data_internal_format>
> enum_values::depth_stencil;
#endif

#ifdef GL_DEPTH_STENCIL_ATTACHMENT
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_other_attachment>
> enum_values::depth_stencil_attachment;
#endif

#ifdef GL_DEPTH_STENCIL_TEXTURE_MODE
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::depth_stencil_texture_mode;
#endif

#ifdef GL_DEPTH_TEST
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::depth_test;
#endif

#ifdef GL_DEPTH_WRITEMASK
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::depth_writemask;
#endif

#ifdef GL_DIFFERENCE_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::difference_khr;
#endif

#ifdef GL_DISPATCH_INDIRECT_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::dispatch_indirect_buffer;
#endif

#ifdef GL_DISPATCH_INDIRECT_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::dispatch_indirect_buffer_binding;
#endif

#ifdef GL_DITHER
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::dither;
#endif

#ifdef GL_DONT_CARE
const enum_value<
	GLenum,
	mp_list<oglplus::debug_output_source,oglplus::debug_output_type,oglplus::hint_option,oglplus::debug_output_severity>
> enum_values::dont_care;
#endif

#ifdef GL_DOUBLE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type,oglplus::pixel_data_type,oglplus::data_type>
> enum_values::double_;
#endif

#ifdef GL_DOUBLE_MAT2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_mat2;
#endif

#ifdef GL_DOUBLE_MAT2x3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_mat2x3;
#endif

#ifdef GL_DOUBLE_MAT2x4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_mat2x4;
#endif

#ifdef GL_DOUBLE_MAT3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_mat3;
#endif

#ifdef GL_DOUBLE_MAT3x2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_mat3x2;
#endif

#ifdef GL_DOUBLE_MAT3x4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_mat3x4;
#endif

#ifdef GL_DOUBLE_MAT4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_mat4;
#endif

#ifdef GL_DOUBLE_MAT4x2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_mat4x2;
#endif

#ifdef GL_DOUBLE_MAT4x3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_mat4x3;
#endif

#ifdef GL_DOUBLE_VEC2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_vec2;
#endif

#ifdef GL_DOUBLE_VEC3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_vec3;
#endif

#ifdef GL_DOUBLE_VEC4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::double_vec4;
#endif

#ifdef GL_DOUBLEBUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::doublebuffer;
#endif

#ifdef GL_DRAW_ARRAYS_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::draw_arrays_command_nv;
#endif

#ifdef GL_DRAW_ARRAYS_INSTANCED_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::draw_arrays_instanced_command_nv;
#endif

#ifdef GL_DRAW_ARRAYS_STRIP_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::draw_arrays_strip_command_nv;
#endif

#ifdef GL_DRAW_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::draw_buffer;
#endif

#ifdef GL_DRAW_BUFFER0
const enum_value<
	GLenum,
	mp_list<oglplus::indexed_value_base>
> enum_values::draw_buffer0;
#endif

#ifdef GL_DRAW_ELEMENTS_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::draw_elements_command_nv;
#endif

#ifdef GL_DRAW_ELEMENTS_INSTANCED_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::draw_elements_instanced_command_nv;
#endif

#ifdef GL_DRAW_ELEMENTS_STRIP_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::draw_elements_strip_command_nv;
#endif

#ifdef GL_DRAW_FRAMEBUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_target>
> enum_values::draw_framebuffer;
#endif

#ifdef GL_DRAW_FRAMEBUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::draw_framebuffer_binding;
#endif

#ifdef GL_DRAW_INDIRECT_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::draw_indirect_buffer;
#endif

#ifdef GL_DRAW_INDIRECT_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::draw_indirect_buffer_binding;
#endif

#ifdef GL_DST_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::dst_alpha;
#endif

#ifdef GL_DST_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::dst_color;
#endif

#ifdef GL_DUP_FIRST_CUBIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::dup_first_cubic_curve_to_nv;
#endif

#ifdef GL_DUP_LAST_CUBIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::dup_last_cubic_curve_to_nv;
#endif

#ifdef GL_DYNAMIC_COPY
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_usage>
> enum_values::dynamic_copy;
#endif

#ifdef GL_DYNAMIC_DRAW
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_usage>
> enum_values::dynamic_draw;
#endif

#ifdef GL_DYNAMIC_READ
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_usage>
> enum_values::dynamic_read;
#endif

#ifdef GL_DYNAMIC_STORAGE_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_storage_bits>
> enum_values::dynamic_storage_bit;
#endif

#ifdef GL_EDGE_FLAG_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::edge_flag_array_address_nv;
#endif

#ifdef GL_ELEMENT_ADDRESS_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::element_address_command_nv;
#endif

#ifdef GL_ELEMENT_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::element_array_address_nv;
#endif

#ifdef GL_ELEMENT_ARRAY_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::element_array_barrier_bit;
#endif

#ifdef GL_ELEMENT_ARRAY_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::element_array_buffer;
#endif

#ifdef GL_ELEMENT_ARRAY_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::element_array_buffer_binding;
#endif

#ifdef GL_EQUAL
const enum_value<
	GLenum,
	mp_list<oglplus::compare_function,oglplus::tess_gen_primitive_spacing>
> enum_values::equal;
#endif

#ifdef GL_EQUIV
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::equiv;
#endif

#ifdef GL_EXCLUSION_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::exclusion_khr;
#endif

#ifdef GL_EXTERNAL_VIRTUAL_MEMORY_BUFFER_AMD
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::external_virtual_memory_buffer;
#endif

#ifdef GL_EYE_LINEAR
const enum_value<
	GLenum,
	mp_list<oglplus::path_gen_mode_nv>
> enum_values::eye_linear;
#endif

#ifdef GL_FALSE
const enum_value<
	GLboolean,
	mp_list<oglplus::true_false>
> enum_values::false_;
#endif

#ifdef GL_FASTEST
const enum_value<
	GLenum,
	mp_list<oglplus::hint_option>
> enum_values::fastest;
#endif

#ifdef GL_FILE_NAME_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_font_target_nv>
> enum_values::file_name_nv;
#endif

#ifdef GL_FILL
const enum_value<
	GLenum,
	mp_list<oglplus::polygon_mode>
> enum_values::fill;
#endif

#ifdef GL_FILL_RECTANGLE_NV
const enum_value<
	GLenum,
	mp_list<oglplus::polygon_mode>
> enum_values::fill_rectangle;
#endif

#ifdef GL_FIRST_TO_REST_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_list_mode_nv>
> enum_values::first_to_rest_nv;
#endif

#ifdef GL_FIRST_VERTEX_CONVENTION
const enum_value<
	GLenum,
	mp_list<oglplus::provoke_mode>
> enum_values::first_vertex_convention;
#endif

#ifdef GL_FIXED
const enum_value<
	GLenum,
	mp_list<oglplus::data_type>
> enum_values::fixed;
#endif

#ifdef GL_FLAT
const enum_value<
	GLenum,
	mp_list<oglplus::path_cap_style_nv>
> enum_values::flat;
#endif

#ifdef GL_FLOAT
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type,oglplus::pixel_data_type,oglplus::data_type>
> enum_values::float_;
#endif

#ifdef GL_FLOAT_32_UNSIGNED_INT_24_8_REV
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::float_32_unsigned_int_24_8_rev;
#endif

#ifdef GL_FLOAT_MAT2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_mat2;
#endif

#ifdef GL_FLOAT_MAT2x3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_mat2x3;
#endif

#ifdef GL_FLOAT_MAT2x4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_mat2x4;
#endif

#ifdef GL_FLOAT_MAT3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_mat3;
#endif

#ifdef GL_FLOAT_MAT3x2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_mat3x2;
#endif

#ifdef GL_FLOAT_MAT3x4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_mat3x4;
#endif

#ifdef GL_FLOAT_MAT4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_mat4;
#endif

#ifdef GL_FLOAT_MAT4x2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_mat4x2;
#endif

#ifdef GL_FLOAT_MAT4x3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_mat4x3;
#endif

#ifdef GL_FLOAT_VEC2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_vec2;
#endif

#ifdef GL_FLOAT_VEC3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_vec3;
#endif

#ifdef GL_FLOAT_VEC4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::float_vec4;
#endif

#ifdef GL_FOG_COORD_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::fog_coord_array_address_nv;
#endif

#ifdef GL_FONT_ASCENDER_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_ascender_bit_nv;
#endif

#ifdef GL_FONT_DESCENDER_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_descender_bit_nv;
#endif

#ifdef GL_FONT_HAS_KERNING_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_has_kerning_bit_nv;
#endif

#ifdef GL_FONT_HEIGHT_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_height_bit_nv;
#endif

#ifdef GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_max_advance_height_bit_nv;
#endif

#ifdef GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_max_advance_width_bit_nv;
#endif

#ifdef GL_FONT_UNDERLINE_POSITION_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_underline_position_bit_nv;
#endif

#ifdef GL_FONT_UNDERLINE_THICKNESS_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_underline_thickness_bit_nv;
#endif

#ifdef GL_FONT_UNITS_PER_EM_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_units_per_em_bit_nv;
#endif

#ifdef GL_FONT_X_MAX_BOUNDS_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_x_max_bounds_bit_nv;
#endif

#ifdef GL_FONT_X_MIN_BOUNDS_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_x_min_bounds_bit_nv;
#endif

#ifdef GL_FONT_Y_MAX_BOUNDS_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_y_max_bounds_bit_nv;
#endif

#ifdef GL_FONT_Y_MIN_BOUNDS_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::font_y_min_bounds_bit_nv;
#endif

#ifdef GL_FRACTIONAL_EVEN
const enum_value<
	GLenum,
	mp_list<oglplus::tess_gen_primitive_spacing>
> enum_values::fractional_even;
#endif

#ifdef GL_FRACTIONAL_ODD
const enum_value<
	GLenum,
	mp_list<oglplus::tess_gen_primitive_spacing>
> enum_values::fractional_odd;
#endif

#ifdef GL_FRAGMENT_COVERAGE_TO_COLOR_NV
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::fragment_coverage_to_color;
#endif

#ifdef GL_FRAGMENT_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::shader_type,oglplus::program_pipeline_parameter>
> enum_values::fragment_shader;
#endif

#ifdef GL_FRAGMENT_SHADER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::program_pipeline_stage>
> enum_values::fragment_shader_bit;
#endif

#ifdef GL_FRAGMENT_SHADER_DERIVATIVE_HINT
const enum_value<
	GLenum,
	mp_list<oglplus::hint_target,oglplus::numeric_query>
> enum_values::fragment_shader_derivative_hint;
#endif

#ifdef GL_FRAGMENT_SHADER_INVOCATIONS_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::fragment_shader_invocations;
#endif

#ifdef GL_FRAGMENT_SUBROUTINE
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::fragment_subroutine;
#endif

#ifdef GL_FRAGMENT_SUBROUTINE_UNIFORM
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::fragment_subroutine_uniform;
#endif

#ifdef GL_FRAMEBUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::object_type>
> enum_values::framebuffer;
#endif

#ifdef GL_FRAMEBUFFER_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::framebuffer_barrier_bit;
#endif

#ifdef GL_FRAMEBUFFER_COMPLETE
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_status>
> enum_values::framebuffer_complete;
#endif

#ifdef GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_status>
> enum_values::framebuffer_incomplete_attachment;
#endif

#ifdef GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_status>
> enum_values::framebuffer_incomplete_layer_targets;
#endif

#ifdef GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_status>
> enum_values::framebuffer_incomplete_missing_attachment;
#endif

#ifdef GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_status>
> enum_values::framebuffer_incomplete_multisample;
#endif

#ifdef GL_FRAMEBUFFER_SRGB
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::framebuffer_srgb;
#endif

#ifdef GL_FRAMEBUFFER_UNDEFINED
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_status>
> enum_values::framebuffer_undefined;
#endif

#ifdef GL_FRAMEBUFFER_UNSUPPORTED
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_status>
> enum_values::framebuffer_unsupported;
#endif

#ifdef GL_FRONT
const enum_value<
	GLenum,
	mp_list<oglplus::color_buffer,oglplus::single_face,oglplus::face>
> enum_values::front;
#endif

#ifdef GL_FRONT_AND_BACK
const enum_value<
	GLenum,
	mp_list<oglplus::color_buffer,oglplus::face>
> enum_values::front_and_back;
#endif

#ifdef GL_FRONT_FACE_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::front_face_command_nv;
#endif

#ifdef GL_FRONT_LEFT
const enum_value<
	GLenum,
	mp_list<oglplus::color_buffer>
> enum_values::front_left;
#endif

#ifdef GL_FRONT_RIGHT
const enum_value<
	GLenum,
	mp_list<oglplus::color_buffer>
> enum_values::front_right;
#endif

#ifdef GL_FUNC_ADD
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation>
> enum_values::func_add;
#endif

#ifdef GL_FUNC_REVERSE_SUBTRACT
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation>
> enum_values::func_reverse_subtract;
#endif

#ifdef GL_FUNC_SUBTRACT
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation>
> enum_values::func_subtract;
#endif

#ifdef GL_GEOMETRY_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::shader_type,oglplus::program_pipeline_parameter>
> enum_values::geometry_shader;
#endif

#ifdef GL_GEOMETRY_SHADER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::program_pipeline_stage>
> enum_values::geometry_shader_bit;
#endif

#ifdef GL_GEOMETRY_SHADER_INVOCATIONS
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::geometry_shader_invocations;
#endif

#ifdef GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::geometry_shader_primitives_emitted;
#endif

#ifdef GL_GEOMETRY_SUBROUTINE
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::geometry_subroutine;
#endif

#ifdef GL_GEOMETRY_SUBROUTINE_UNIFORM
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::geometry_subroutine_uniform;
#endif

#ifdef GL_GEQUAL
const enum_value<
	GLenum,
	mp_list<oglplus::compare_function>
> enum_values::gequal;
#endif

#ifdef GL_GLYPH_HAS_KERNING_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::glyph_has_kerning_bit_nv;
#endif

#ifdef GL_GLYPH_HEIGHT_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::glyph_height_bit_nv;
#endif

#ifdef GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::glyph_horizontal_bearing_advance_bit_nv;
#endif

#ifdef GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::glyph_horizontal_bearing_x_bit_nv;
#endif

#ifdef GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::glyph_horizontal_bearing_y_bit_nv;
#endif

#ifdef GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::glyph_vertical_bearing_advance_bit_nv;
#endif

#ifdef GL_GLYPH_VERTICAL_BEARING_X_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::glyph_vertical_bearing_x_bit_nv;
#endif

#ifdef GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::glyph_vertical_bearing_y_bit_nv;
#endif

#ifdef GL_GLYPH_WIDTH_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_metric_query_nv>
> enum_values::glyph_width_bit_nv;
#endif

#ifdef GL_GREATER
const enum_value<
	GLenum,
	mp_list<oglplus::compare_function>
> enum_values::greater;
#endif

#ifdef GL_GREEN
const enum_value<
	GLenum,
	mp_list<oglplus::texture_swizzle_mode,oglplus::pixel_data_format>
> enum_values::green;
#endif

#ifdef GL_GREEN_INTEGER
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::green_integer;
#endif

#ifdef GL_GUILTY_CONTEXT_RESET
const enum_value<
	GLenum,
	mp_list<oglplus::graphics_reset_status>
> enum_values::guilty_context_reset;
#endif

#ifdef GL_HALF_FLOAT
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type,oglplus::data_type>
> enum_values::half_float;
#endif

#ifdef GL_HARDLIGHT_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::hardlight_khr;
#endif

#ifdef GL_HIGH_FLOAT
const enum_value<
	GLenum,
	mp_list<oglplus::precision_type>
> enum_values::high_float;
#endif

#ifdef GL_HIGH_INT
const enum_value<
	GLenum,
	mp_list<oglplus::precision_type>
> enum_values::high_int;
#endif

#ifdef GL_HORIZONTAL_LINE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::horizontal_line_to_nv;
#endif

#ifdef GL_HSL_COLOR_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::hsl_color_khr;
#endif

#ifdef GL_HSL_HUE_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::hsl_hue_khr;
#endif

#ifdef GL_HSL_LUMINOSITY_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::hsl_luminosity_khr;
#endif

#ifdef GL_HSL_SATURATION_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::hsl_saturation_khr;
#endif

#ifdef GL_IMAGE_1D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_1d;
#endif

#ifdef GL_IMAGE_1D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_1d_array;
#endif

#ifdef GL_IMAGE_2D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_2d;
#endif

#ifdef GL_IMAGE_2D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_2d_array;
#endif

#ifdef GL_IMAGE_2D_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_2d_multisample;
#endif

#ifdef GL_IMAGE_2D_MULTISAMPLE_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_2d_multisample_array;
#endif

#ifdef GL_IMAGE_2D_RECT
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_2d_rect;
#endif

#ifdef GL_IMAGE_3D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_3d;
#endif

#ifdef GL_IMAGE_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_buffer;
#endif

#ifdef GL_IMAGE_CUBE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::image_cube;
#endif

#ifdef GL_IMAGE_FORMAT_COMPATIBILITY_TYPE
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::image_format_compatibility_type;
#endif

#ifdef GL_IMPLEMENTATION_COLOR_READ_FORMAT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::implementation_color_read_format;
#endif

#ifdef GL_IMPLEMENTATION_COLOR_READ_TYPE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::implementation_color_read_type;
#endif

#ifdef GL_INCR
const enum_value<
	GLenum,
	mp_list<oglplus::stencil_operation>
> enum_values::incr;
#endif

#ifdef GL_INCR_WRAP
const enum_value<
	GLenum,
	mp_list<oglplus::stencil_operation>
> enum_values::incr_wrap;
#endif

#ifdef GL_INDEX_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::index_array_address_nv;
#endif

#ifdef GL_INFO_LOG_LENGTH
const enum_value<
	GLenum,
	mp_list<oglplus::shader_parameter,oglplus::program_parameter,oglplus::program_pipeline_parameter>
> enum_values::info_log_length;
#endif

#ifdef GL_INNOCENT_CONTEXT_RESET
const enum_value<
	GLenum,
	mp_list<oglplus::graphics_reset_status>
> enum_values::innocent_context_reset;
#endif

#ifdef GL_INT
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type,oglplus::pixel_data_type,oglplus::data_type>
> enum_values::int_;
#endif

#ifdef GL_INT_IMAGE_1D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_1d;
#endif

#ifdef GL_INT_IMAGE_1D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_1d_array;
#endif

#ifdef GL_INT_IMAGE_2D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_2d;
#endif

#ifdef GL_INT_IMAGE_2D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_2d_array;
#endif

#ifdef GL_INT_IMAGE_2D_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_2d_multisample;
#endif

#ifdef GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_2d_multisample_array;
#endif

#ifdef GL_INT_IMAGE_2D_RECT
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_2d_rect;
#endif

#ifdef GL_INT_IMAGE_3D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_3d;
#endif

#ifdef GL_INT_IMAGE_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_buffer;
#endif

#ifdef GL_INT_IMAGE_CUBE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_image_cube;
#endif

#ifdef GL_INT_SAMPLER_1D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_1d;
#endif

#ifdef GL_INT_SAMPLER_1D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_1d_array;
#endif

#ifdef GL_INT_SAMPLER_2D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_2d;
#endif

#ifdef GL_INT_SAMPLER_2D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_2d_array;
#endif

#ifdef GL_INT_SAMPLER_2D_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_2d_multisample;
#endif

#ifdef GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_2d_multisample_array;
#endif

#ifdef GL_INT_SAMPLER_2D_RECT
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_2d_rect;
#endif

#ifdef GL_INT_SAMPLER_3D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_3d;
#endif

#ifdef GL_INT_SAMPLER_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_buffer;
#endif

#ifdef GL_INT_SAMPLER_CUBE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_cube;
#endif

#ifdef GL_INT_SAMPLER_CUBE_MAP_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_sampler_cube_map_array;
#endif

#ifdef GL_INT_VEC2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_vec2;
#endif

#ifdef GL_INT_VEC3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_vec3;
#endif

#ifdef GL_INT_VEC4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::int_vec4;
#endif

#ifdef GL_INTENSITY
const enum_value<
	GLenum,
	mp_list<oglplus::path_color_format_nv>
> enum_values::intensity;
#endif

#ifdef GL_INTERLEAVED_ATTRIBS
const enum_value<
	GLenum,
	mp_list<oglplus::transform_feedback_mode>
> enum_values::interleaved_attribs;
#endif

#ifdef GL_INVALID_ENUM
const enum_value<
	GLenum,
	mp_list<oglplus::error_code>
> enum_values::invalid_enum;
#endif

#ifdef GL_INVALID_FRAMEBUFFER_OPERATION
const enum_value<
	GLenum,
	mp_list<oglplus::error_code>
> enum_values::invalid_framebuffer_operation;
#endif

#ifdef GL_INVALID_OPERATION
const enum_value<
	GLenum,
	mp_list<oglplus::error_code>
> enum_values::invalid_operation;
#endif

#ifdef GL_INVALID_VALUE
const enum_value<
	GLenum,
	mp_list<oglplus::error_code>
> enum_values::invalid_value;
#endif

#ifdef GL_INVERT
const enum_value<
	GLenum,
	mp_list<oglplus::path_fill_mode_nv,oglplus::color_logic_operation,oglplus::stencil_operation>
> enum_values::invert;
#endif

#ifdef GL_IS_PER_PATCH
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::is_per_patch;
#endif

#ifdef GL_IS_ROW_MAJOR
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::is_row_major;
#endif

#ifdef GL_ISOLINES
const enum_value<
	GLenum,
	mp_list<oglplus::tess_gen_primitive_type>
> enum_values::isolines;
#endif

#ifdef GL_ITALIC_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::path_font_style_nv>
> enum_values::italic_bit_nv;
#endif

#ifdef GL_KEEP
const enum_value<
	GLenum,
	mp_list<oglplus::stencil_operation>
> enum_values::keep;
#endif

#ifdef GL_LARGE_CCW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::large_ccw_arc_to_nv;
#endif

#ifdef GL_LARGE_CW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::large_cw_arc_to_nv;
#endif

#ifdef GL_LAST_VERTEX_CONVENTION
const enum_value<
	GLenum,
	mp_list<oglplus::provoke_mode>
> enum_values::last_vertex_convention;
#endif

#ifdef GL_LAYER_PROVOKING_VERTEX
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::layer_provoking_vertex;
#endif

#ifdef GL_LEFT
const enum_value<
	GLenum,
	mp_list<oglplus::color_buffer>
> enum_values::left;
#endif

#ifdef GL_LEQUAL
const enum_value<
	GLenum,
	mp_list<oglplus::compare_function>
> enum_values::lequal;
#endif

#ifdef GL_LESS
const enum_value<
	GLenum,
	mp_list<oglplus::compare_function>
> enum_values::less;
#endif

#ifdef GL_LIGHTEN_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::lighten_khr;
#endif

#ifdef GL_LINE
const enum_value<
	GLenum,
	mp_list<oglplus::polygon_mode>
> enum_values::line;
#endif

#ifdef GL_LINE_LOOP
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type,oglplus::old_primitive_type>
> enum_values::line_loop;
#endif

#ifdef GL_LINE_SMOOTH
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::line_smooth;
#endif

#ifdef GL_LINE_SMOOTH_HINT
const enum_value<
	GLenum,
	mp_list<oglplus::hint_target,oglplus::numeric_query>
> enum_values::line_smooth_hint;
#endif

#ifdef GL_LINE_STRIP
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type,oglplus::old_primitive_type>
> enum_values::line_strip;
#endif

#ifdef GL_LINE_STRIP_ADJACENCY
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type>
> enum_values::line_strip_adjacency;
#endif

#ifdef GL_LINE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::line_to_nv;
#endif

#ifdef GL_LINE_WIDTH
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::line_width;
#endif

#ifdef GL_LINE_WIDTH_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::line_width_command_nv;
#endif

#ifdef GL_LINEAR
const enum_value<
	GLenum,
	mp_list<oglplus::texture_mag_filter,oglplus::blit_filter,oglplus::texture_filter,oglplus::texture_min_filter>
> enum_values::linear;
#endif

#ifdef GL_LINEAR_MIPMAP_LINEAR
const enum_value<
	GLenum,
	mp_list<oglplus::texture_min_filter>
> enum_values::linear_mipmap_linear;
#endif

#ifdef GL_LINEAR_MIPMAP_NEAREST
const enum_value<
	GLenum,
	mp_list<oglplus::texture_min_filter>
> enum_values::linear_mipmap_nearest;
#endif

#ifdef GL_LINES
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type,oglplus::old_primitive_type,oglplus::transform_feedback_primitive_type>
> enum_values::lines;
#endif

#ifdef GL_LINES_ADJACENCY
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type>
> enum_values::lines_adjacency;
#endif

#ifdef GL_LINK_STATUS
const enum_value<
	GLenum,
	mp_list<oglplus::program_parameter>
> enum_values::link_status;
#endif

#ifdef GL_LOCATION
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::location;
#endif

#ifdef GL_LOCATION_COMPONENT
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::location_component;
#endif

#ifdef GL_LOCATION_INDEX
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::location_index;
#endif

#ifdef GL_LOGIC_OP_MODE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::logic_op_mode;
#endif

#ifdef GL_LOSE_CONTEXT_ON_RESET
const enum_value<
	GLenum,
	mp_list<oglplus::reset_notification_strategy>
> enum_values::lose_context_on_reset;
#endif

#ifdef GL_LOW_FLOAT
const enum_value<
	GLenum,
	mp_list<oglplus::precision_type>
> enum_values::low_float;
#endif

#ifdef GL_LOW_INT
const enum_value<
	GLenum,
	mp_list<oglplus::precision_type>
> enum_values::low_int;
#endif

#ifdef GL_LOWER_LEFT
const enum_value<
	GLenum,
	mp_list<oglplus::clip_origin>
> enum_values::lower_left;
#endif

#ifdef GL_LUMINANCE
const enum_value<
	GLenum,
	mp_list<oglplus::path_color_format_nv>
> enum_values::luminance;
#endif

#ifdef GL_LUMINANCE_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::path_color_format_nv>
> enum_values::luminance_alpha;
#endif

#ifdef GL_MAP_COHERENT_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_storage_bits,oglplus::buffer_map_access>
> enum_values::map_coherent_bit;
#endif

#ifdef GL_MAP_FLUSH_EXPLICIT_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_map_access>
> enum_values::map_flush_explicit_bit;
#endif

#ifdef GL_MAP_INVALIDATE_BUFFER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_map_access>
> enum_values::map_invalidate_buffer_bit;
#endif

#ifdef GL_MAP_INVALIDATE_RANGE_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_map_access>
> enum_values::map_invalidate_range_bit;
#endif

#ifdef GL_MAP_PERSISTENT_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_storage_bits,oglplus::buffer_map_access>
> enum_values::map_persistent_bit;
#endif

#ifdef GL_MAP_READ_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_storage_bits,oglplus::buffer_map_access>
> enum_values::map_read_bit;
#endif

#ifdef GL_MAP_UNSYNCHRONIZED_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_map_access>
> enum_values::map_unsynchronized_bit;
#endif

#ifdef GL_MAP_WRITE_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_storage_bits,oglplus::buffer_map_access>
> enum_values::map_write_bit;
#endif

#ifdef GL_MATRIX_STRIDE
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::matrix_stride;
#endif

#ifdef GL_MAX
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation>
> enum_values::max;
#endif

#ifdef GL_MAX_3D_TEXTURE_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_3d_texture_size;
#endif

#ifdef GL_MAX_ARRAY_TEXTURE_LAYERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_array_texture_layers;
#endif

#ifdef GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_atomic_counter_buffer_bindings;
#endif

#ifdef GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_atomic_counter_buffer_size;
#endif

#ifdef GL_MAX_CLIP_DISTANCES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_clip_distances;
#endif

#ifdef GL_MAX_COLOR_ATTACHMENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_color_attachments;
#endif

#ifdef GL_MAX_COLOR_TEXTURE_SAMPLES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_color_texture_samples;
#endif

#ifdef GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_atomic_counter_buffers;
#endif

#ifdef GL_MAX_COMBINED_ATOMIC_COUNTERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_atomic_counters;
#endif

#ifdef GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_clip_and_cull_distances;
#endif

#ifdef GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_fragment_uniform_components;
#endif

#ifdef GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_geometry_uniform_components;
#endif

#ifdef GL_MAX_COMBINED_IMAGE_UNIFORMS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_image_uniforms;
#endif

#ifdef GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_image_units_and_fragment_outputs;
#endif

#ifdef GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_tess_control_uniform_components;
#endif

#ifdef GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_tess_evaluation_uniform_components;
#endif

#ifdef GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_texture_image_units;
#endif

#ifdef GL_MAX_COMBINED_UNIFORM_BLOCKS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_uniform_blocks;
#endif

#ifdef GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_combined_vertex_uniform_components;
#endif

#ifdef GL_MAX_COMPUTE_SHARED_MEMORY_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_compute_shared_memory_size;
#endif

#ifdef GL_MAX_COMPUTE_WORK_GROUP_COUNT
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_compute_work_group_count;
#endif

#ifdef GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_compute_work_group_invocations;
#endif

#ifdef GL_MAX_COMPUTE_WORK_GROUP_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_compute_work_group_size;
#endif

#ifdef GL_MAX_CUBE_MAP_TEXTURE_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_cube_map_texture_size;
#endif

#ifdef GL_MAX_CULL_DISTANCES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_cull_distances;
#endif

#ifdef GL_MAX_DEPTH_TEXTURE_SAMPLES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_depth_texture_samples;
#endif

#ifdef GL_MAX_DRAW_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_draw_buffers;
#endif

#ifdef GL_MAX_DUAL_SOURCE_DRAW_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_dual_source_draw_buffers;
#endif

#ifdef GL_MAX_ELEMENTS_INDICES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_elements_indices;
#endif

#ifdef GL_MAX_ELEMENTS_VERTICES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_elements_vertices;
#endif

#ifdef GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_fragment_atomic_counter_buffers;
#endif

#ifdef GL_MAX_FRAGMENT_ATOMIC_COUNTERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_fragment_atomic_counters;
#endif

#ifdef GL_MAX_FRAGMENT_IMAGE_UNIFORMS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_fragment_image_uniforms;
#endif

#ifdef GL_MAX_FRAGMENT_INPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_fragment_input_components;
#endif

#ifdef GL_MAX_FRAGMENT_INTERPOLATION_OFFSET
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_fragment_interpolation_offset;
#endif

#ifdef GL_MAX_FRAGMENT_UNIFORM_BLOCKS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_fragment_uniform_blocks;
#endif

#ifdef GL_MAX_FRAGMENT_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_fragment_uniform_components;
#endif

#ifdef GL_MAX_FRAGMENT_UNIFORM_VECTORS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_fragment_uniform_vectors;
#endif

#ifdef GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_atomic_counter_buffers;
#endif

#ifdef GL_MAX_GEOMETRY_ATOMIC_COUNTERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_atomic_counters;
#endif

#ifdef GL_MAX_GEOMETRY_IMAGE_UNIFORMS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_image_uniforms;
#endif

#ifdef GL_MAX_GEOMETRY_INPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_input_components;
#endif

#ifdef GL_MAX_GEOMETRY_OUTPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_output_components;
#endif

#ifdef GL_MAX_GEOMETRY_OUTPUT_VERTICES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_output_vertices;
#endif

#ifdef GL_MAX_GEOMETRY_SHADER_INVOCATIONS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_shader_invocations;
#endif

#ifdef GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_texture_image_units;
#endif

#ifdef GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_total_output_components;
#endif

#ifdef GL_MAX_GEOMETRY_UNIFORM_BLOCKS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_uniform_blocks;
#endif

#ifdef GL_MAX_GEOMETRY_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_geometry_uniform_components;
#endif

#ifdef GL_MAX_IMAGE_SAMPLES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_image_samples;
#endif

#ifdef GL_MAX_IMAGE_UNITS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_image_units;
#endif

#ifdef GL_MAX_INTEGER_SAMPLES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_integer_samples;
#endif

#ifdef GL_MAX_PATCH_VERTICES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_patch_vertices;
#endif

#ifdef GL_MAX_PROGRAM_TEXEL_OFFSET
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_program_texel_offset;
#endif

#ifdef GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_program_texture_gather_offset;
#endif

#ifdef GL_MAX_RECTANGLE_TEXTURE_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_rectangle_texture_size;
#endif

#ifdef GL_MAX_RENDERBUFFER_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_renderbuffer_size;
#endif

#ifdef GL_MAX_SAMPLE_MASK_WORDS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_sample_mask_words;
#endif

#ifdef GL_MAX_SAMPLES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_samples;
#endif

#ifdef GL_MAX_SERVER_WAIT_TIMEOUT
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_server_wait_timeout;
#endif

#ifdef GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_subroutine_uniform_locations;
#endif

#ifdef GL_MAX_SUBROUTINES
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_subroutines;
#endif

#ifdef GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_control_atomic_counter_buffers;
#endif

#ifdef GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_control_atomic_counters;
#endif

#ifdef GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_control_image_uniforms;
#endif

#ifdef GL_MAX_TESS_CONTROL_INPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_control_input_components;
#endif

#ifdef GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_control_output_components;
#endif

#ifdef GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_control_texture_image_units;
#endif

#ifdef GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_control_total_output_components;
#endif

#ifdef GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_control_uniform_blocks;
#endif

#ifdef GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_control_uniform_components;
#endif

#ifdef GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_evaluation_atomic_counter_buffers;
#endif

#ifdef GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_evaluation_atomic_counters;
#endif

#ifdef GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_evaluation_image_uniforms;
#endif

#ifdef GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_evaluation_input_components;
#endif

#ifdef GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_evaluation_output_components;
#endif

#ifdef GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_evaluation_texture_image_units;
#endif

#ifdef GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_evaluation_uniform_blocks;
#endif

#ifdef GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_evaluation_uniform_components;
#endif

#ifdef GL_MAX_TESS_GEN_LEVEL
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_gen_level;
#endif

#ifdef GL_MAX_TESS_PATCH_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_tess_patch_components;
#endif

#ifdef GL_MAX_TEXTURE_BUFFER_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_texture_buffer_size;
#endif

#ifdef GL_MAX_TEXTURE_IMAGE_UNITS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_texture_image_units;
#endif

#ifdef GL_MAX_TEXTURE_LOD_BIAS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_texture_lod_bias;
#endif

#ifdef GL_MAX_TEXTURE_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_texture_size;
#endif

#ifdef GL_MAX_TRANSFORM_FEEDBACK_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_transform_feedback_buffers;
#endif

#ifdef GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_transform_feedback_interleaved_components;
#endif

#ifdef GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_transform_feedback_separate_attribs;
#endif

#ifdef GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_transform_feedback_separate_components;
#endif

#ifdef GL_MAX_UNIFORM_BLOCK_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_uniform_block_size;
#endif

#ifdef GL_MAX_UNIFORM_BUFFER_BINDINGS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_uniform_buffer_bindings;
#endif

#ifdef GL_MAX_VARYING_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_varying_components;
#endif

#ifdef GL_MAX_VARYING_VECTORS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_varying_vectors;
#endif

#ifdef GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_atomic_counter_buffers;
#endif

#ifdef GL_MAX_VERTEX_ATOMIC_COUNTERS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_atomic_counters;
#endif

#ifdef GL_MAX_VERTEX_ATTRIBS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_attribs;
#endif

#ifdef GL_MAX_VERTEX_IMAGE_UNIFORMS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_image_uniforms;
#endif

#ifdef GL_MAX_VERTEX_OUTPUT_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_output_components;
#endif

#ifdef GL_MAX_VERTEX_STREAMS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_streams;
#endif

#ifdef GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_texture_image_units;
#endif

#ifdef GL_MAX_VERTEX_UNIFORM_BLOCKS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_uniform_blocks;
#endif

#ifdef GL_MAX_VERTEX_UNIFORM_COMPONENTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_uniform_components;
#endif

#ifdef GL_MAX_VERTEX_UNIFORM_VECTORS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_vertex_uniform_vectors;
#endif

#ifdef GL_MAX_VIEWPORT_DIMS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_viewport_dims;
#endif

#ifdef GL_MAX_VIEWPORTS
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::max_viewports;
#endif

#ifdef GL_MEDIUM_FLOAT
const enum_value<
	GLenum,
	mp_list<oglplus::precision_type>
> enum_values::medium_float;
#endif

#ifdef GL_MEDIUM_INT
const enum_value<
	GLenum,
	mp_list<oglplus::precision_type>
> enum_values::medium_int;
#endif

#ifdef GL_MIN
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation>
> enum_values::min;
#endif

#ifdef GL_MIN_FRAGMENT_INTERPOLATION_OFFSET
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::min_fragment_interpolation_offset;
#endif

#ifdef GL_MIN_MAP_BUFFER_ALIGNMENT
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::min_map_buffer_alignment;
#endif

#ifdef GL_MIN_PROGRAM_TEXEL_OFFSET
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::min_program_texel_offset;
#endif

#ifdef GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET
const enum_value<
	GLenum,
	mp_list<oglplus::limit_query>
> enum_values::min_program_texture_gather_offset;
#endif

#ifdef GL_MIRROR_CLAMP_TO_EDGE
const enum_value<
	GLenum,
	mp_list<oglplus::texture_wrap_mode>
> enum_values::mirror_clamp_to_edge;
#endif

#ifdef GL_MIRRORED_REPEAT
const enum_value<
	GLenum,
	mp_list<oglplus::texture_wrap_mode>
> enum_values::mirrored_repeat;
#endif

#ifdef GL_MITER_REVERT_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_join_style_nv>
> enum_values::miter_revert_nv;
#endif

#ifdef GL_MITER_TRUNCATE_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_join_style_nv>
> enum_values::miter_truncate_nv;
#endif

#ifdef GL_MODELVIEW
const enum_value<
	GLenum,
	mp_list<oglplus::old_matrix_mode>
> enum_values::modelview;
#endif

#ifdef GL_MOVE_TO_CONTINUES_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_dash_offset_reset_nv>
> enum_values::move_to_continues_nv;
#endif

#ifdef GL_MOVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::move_to_nv;
#endif

#ifdef GL_MOVE_TO_RESET_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_dash_offset_reset_nv>
> enum_values::move_to_reset_nv;
#endif

#ifdef GL_MULTIPLY_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::multiply_khr;
#endif

#ifdef GL_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::multisample;
#endif

#ifdef GL_NAMED_STRING_LENGTH_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::named_string_param>
> enum_values::named_string_length;
#endif

#ifdef GL_NAMED_STRING_TYPE_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::named_string_param>
> enum_values::named_string_type;
#endif

#ifdef GL_NAND
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::nand;
#endif

#ifdef GL_NEAREST
const enum_value<
	GLenum,
	mp_list<oglplus::texture_mag_filter,oglplus::blit_filter,oglplus::texture_filter,oglplus::texture_min_filter>
> enum_values::nearest;
#endif

#ifdef GL_NEAREST_MIPMAP_LINEAR
const enum_value<
	GLenum,
	mp_list<oglplus::texture_min_filter>
> enum_values::nearest_mipmap_linear;
#endif

#ifdef GL_NEAREST_MIPMAP_NEAREST
const enum_value<
	GLenum,
	mp_list<oglplus::texture_min_filter>
> enum_values::nearest_mipmap_nearest;
#endif

#ifdef GL_NEGATIVE_ONE_TO_ONE
const enum_value<
	GLenum,
	mp_list<oglplus::clip_depth_mode>
> enum_values::negative_one_to_one;
#endif

#ifdef GL_NEVER
const enum_value<
	GLenum,
	mp_list<oglplus::compare_function>
> enum_values::never;
#endif

#ifdef GL_NICEST
const enum_value<
	GLenum,
	mp_list<oglplus::hint_option>
> enum_values::nicest;
#endif

#ifdef GL_NO_ERROR
const enum_value<
	GLenum,
	mp_list<oglplus::graphics_reset_status,oglplus::error_code>
> enum_values::no_error;
#endif

#ifdef GL_NO_RESET_NOTIFICATION
const enum_value<
	GLenum,
	mp_list<oglplus::reset_notification_strategy>
> enum_values::no_reset_notification;
#endif

#ifdef GL_NONE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type,oglplus::context_release_behavior,oglplus::color_buffer,oglplus::object_type,oglplus::texture_compare_mode,oglplus::path_transform_type_nv,oglplus::path_join_style_nv,oglplus::path_gen_mode_nv>
> enum_values::none;
#endif

#ifdef GL_NOOP
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::noop;
#endif

#ifdef GL_NOP_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::nop_command_nv;
#endif

#ifdef GL_NOR
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::nor;
#endif

#ifdef GL_NORMAL_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::normal_array_address_nv;
#endif

#ifdef GL_NOTEQUAL
const enum_value<
	GLenum,
	mp_list<oglplus::compare_function>
> enum_values::notequal;
#endif

#ifdef GL_NUM_ACTIVE_VARIABLES
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::num_active_variables;
#endif

#ifdef GL_NUM_COMPATIBLE_SUBROUTINES
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::num_compatible_subroutines;
#endif

#ifdef GL_NUM_COMPRESSED_TEXTURE_FORMATS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::num_compressed_texture_formats;
#endif

#ifdef GL_NUM_EXTENSIONS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::num_extensions;
#endif

#ifdef GL_NUM_PROGRAM_BINARY_FORMATS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::num_program_binary_formats;
#endif

#ifdef GL_NUM_SHADER_BINARY_FORMATS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::num_shader_binary_formats;
#endif

#ifdef GL_OBJECT_LINEAR
const enum_value<
	GLenum,
	mp_list<oglplus::path_gen_mode_nv>
> enum_values::object_linear;
#endif

#ifdef GL_OFFSET
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::offset;
#endif

#ifdef GL_ONE
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function,oglplus::texture_swizzle_mode>
> enum_values::one;
#endif

#ifdef GL_ONE_MINUS_CONSTANT_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::one_minus_constant_alpha;
#endif

#ifdef GL_ONE_MINUS_CONSTANT_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::one_minus_constant_color;
#endif

#ifdef GL_ONE_MINUS_DST_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::one_minus_dst_alpha;
#endif

#ifdef GL_ONE_MINUS_DST_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::one_minus_dst_color;
#endif

#ifdef GL_ONE_MINUS_SRC1_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::one_minus_src1_alpha;
#endif

#ifdef GL_ONE_MINUS_SRC1_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::one_minus_src1_color;
#endif

#ifdef GL_ONE_MINUS_SRC_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::one_minus_src_alpha;
#endif

#ifdef GL_ONE_MINUS_SRC_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::one_minus_src_color;
#endif

#ifdef GL_OR
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::or_;
#endif

#ifdef GL_OR_INVERTED
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::or_inverted;
#endif

#ifdef GL_OR_REVERSE
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::or_reverse;
#endif

#ifdef GL_OUT_OF_MEMORY
const enum_value<
	GLenum,
	mp_list<oglplus::error_code>
> enum_values::out_of_memory;
#endif

#ifdef GL_OVERLAY_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::overlay_khr;
#endif

#ifdef GL_PACK_ALIGNMENT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::pack_alignment;
#endif

#ifdef GL_PACK_COMPRESSED_BLOCK_DEPTH
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_parameter>
> enum_values::pack_compressed_block_depth;
#endif

#ifdef GL_PACK_COMPRESSED_BLOCK_HEIGHT
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_parameter>
> enum_values::pack_compressed_block_height;
#endif

#ifdef GL_PACK_COMPRESSED_BLOCK_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_parameter>
> enum_values::pack_compressed_block_size;
#endif

#ifdef GL_PACK_COMPRESSED_BLOCK_WIDTH
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_parameter>
> enum_values::pack_compressed_block_width;
#endif

#ifdef GL_PACK_IMAGE_HEIGHT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::pack_image_height;
#endif

#ifdef GL_PACK_LSB_FIRST
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::pack_lsb_first;
#endif

#ifdef GL_PACK_ROW_LENGTH
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::pack_row_length;
#endif

#ifdef GL_PACK_SKIP_IMAGES
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::pack_skip_images;
#endif

#ifdef GL_PACK_SKIP_PIXELS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::pack_skip_pixels;
#endif

#ifdef GL_PACK_SKIP_ROWS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::pack_skip_rows;
#endif

#ifdef GL_PACK_SWAP_BYTES
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::pack_swap_bytes;
#endif

#ifdef GL_PARAMETER_BUFFER_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::parameter_buffer;
#endif

#ifdef GL_PARAMETER_BUFFER_BINDING_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::parameter_buffer_binding;
#endif

#ifdef GL_PATCH_DEFAULT_INNER_LEVEL
const enum_value<
	GLenum,
	mp_list<oglplus::patch_parameter>
> enum_values::patch_default_inner_level;
#endif

#ifdef GL_PATCH_DEFAULT_OUTER_LEVEL
const enum_value<
	GLenum,
	mp_list<oglplus::patch_parameter>
> enum_values::patch_default_outer_level;
#endif

#ifdef GL_PATCH_VERTICES
const enum_value<
	GLenum,
	mp_list<oglplus::patch_parameter>
> enum_values::patch_vertices;
#endif

#ifdef GL_PATCHES
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type>
> enum_values::patches;
#endif

#ifdef GL_PATH_CLIENT_LENGTH_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_client_length_nv;
#endif

#ifdef GL_PATH_COMMAND_COUNT_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_command_count_nv;
#endif

#ifdef GL_PATH_COMPUTED_LENGTH_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_computed_length_nv;
#endif

#ifdef GL_PATH_COORD_COUNT_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_coord_count_nv;
#endif

#ifdef GL_PATH_DASH_ARRAY_COUNT_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_dash_array_count_nv;
#endif

#ifdef GL_PATH_DASH_OFFSET_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_dash_offset_nv;
#endif

#ifdef GL_PATH_DASH_OFFSET_RESET_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_dash_offset_reset_nv;
#endif

#ifdef GL_PATH_FILL_BOUNDING_BOX_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_fill_bounding_box_nv;
#endif

#ifdef GL_PATH_FILL_COVER_MODE_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_fill_cover_mode_nv,oglplus::path_parameter_nv>
> enum_values::path_fill_cover_mode_nv;
#endif

#ifdef GL_PATH_FILL_MASK_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_fill_mask_nv;
#endif

#ifdef GL_PATH_FILL_MODE_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_fill_mode_nv,oglplus::path_parameter_nv>
> enum_values::path_fill_mode_nv;
#endif

#ifdef GL_PATH_FORMAT_PS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_format_nv>
> enum_values::path_format_ps_nv;
#endif

#ifdef GL_PATH_FORMAT_SVG_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_format_nv>
> enum_values::path_format_svg_nv;
#endif

#ifdef GL_PATH_INITIAL_DASH_CAP_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_initial_dash_cap_nv;
#endif

#ifdef GL_PATH_INITIAL_END_CAP_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_initial_end_cap_nv;
#endif

#ifdef GL_PATH_JOIN_STYLE_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_join_style_nv;
#endif

#ifdef GL_PATH_MITER_LIMIT_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_miter_limit_nv;
#endif

#ifdef GL_PATH_OBJECT_BOUNDING_BOX_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv,oglplus::path_gen_mode_nv>
> enum_values::path_object_bounding_box_nv;
#endif

#ifdef GL_PATH_STROKE_BOUND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_stroke_bound_nv;
#endif

#ifdef GL_PATH_STROKE_BOUNDING_BOX_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_stroke_bounding_box_nv;
#endif

#ifdef GL_PATH_STROKE_COVER_MODE_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_stroke_cover_mode_nv,oglplus::path_parameter_nv>
> enum_values::path_stroke_cover_mode_nv;
#endif

#ifdef GL_PATH_STROKE_MASK_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_stroke_mask_nv;
#endif

#ifdef GL_PATH_STROKE_WIDTH_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_stroke_width_nv;
#endif

#ifdef GL_PATH_TERMINAL_DASH_CAP_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_terminal_dash_cap_nv;
#endif

#ifdef GL_PATH_TERMINAL_END_CAP_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_parameter_nv>
> enum_values::path_terminal_end_cap_nv;
#endif

#ifdef GL_PIXEL_BUFFER_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::pixel_buffer_barrier_bit;
#endif

#ifdef GL_PIXEL_PACK_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::pixel_pack_buffer;
#endif

#ifdef GL_PIXEL_PACK_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::pixel_pack_buffer_binding;
#endif

#ifdef GL_PIXEL_UNPACK_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::pixel_unpack_buffer;
#endif

#ifdef GL_PIXEL_UNPACK_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::pixel_unpack_buffer_binding;
#endif

#ifdef GL_POINT
const enum_value<
	GLenum,
	mp_list<oglplus::polygon_mode>
> enum_values::point;
#endif

#ifdef GL_POINT_FADE_THRESHOLD_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::point_fade_threshold_size;
#endif

#ifdef GL_POINT_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::point_size;
#endif

#ifdef GL_POINT_SIZE_GRANULARITY
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::point_size_granularity;
#endif

#ifdef GL_POINT_SIZE_RANGE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::point_size_range;
#endif

#ifdef GL_POINTS
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type,oglplus::old_primitive_type,oglplus::transform_feedback_primitive_type>
> enum_values::points;
#endif

#ifdef GL_POLYGON
const enum_value<
	GLenum,
	mp_list<oglplus::old_primitive_type>
> enum_values::polygon;
#endif

#ifdef GL_POLYGON_OFFSET_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::polygon_offset_command_nv;
#endif

#ifdef GL_POLYGON_OFFSET_FACTOR
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::polygon_offset_factor;
#endif

#ifdef GL_POLYGON_OFFSET_FILL
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::polygon_offset_fill;
#endif

#ifdef GL_POLYGON_OFFSET_LINE
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::polygon_offset_line;
#endif

#ifdef GL_POLYGON_OFFSET_POINT
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::polygon_offset_point;
#endif

#ifdef GL_POLYGON_OFFSET_UNITS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::polygon_offset_units;
#endif

#ifdef GL_POLYGON_SMOOTH
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::polygon_smooth;
#endif

#ifdef GL_POLYGON_SMOOTH_HINT
const enum_value<
	GLenum,
	mp_list<oglplus::hint_target,oglplus::numeric_query>
> enum_values::polygon_smooth_hint;
#endif

#ifdef GL_PRIMARY_COLOR_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_color_nv>
> enum_values::primary_color_nv;
#endif

#ifdef GL_PRIMITIVE_RESTART
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::primitive_restart;
#endif

#ifdef GL_PRIMITIVE_RESTART_INDEX
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::primitive_restart_index;
#endif

#ifdef GL_PRIMITIVES_GENERATED
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::primitives_generated;
#endif

#ifdef GL_PRIMITIVES_SUBMITTED_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::primitives_submitted;
#endif

#ifdef GL_PROGRAM
const enum_value<
	GLenum,
	mp_list<oglplus::object_type>
> enum_values::program;
#endif

#ifdef GL_PROGRAM_BINARY_FORMATS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::program_binary_formats;
#endif

#ifdef GL_PROGRAM_INPUT
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::program_input;
#endif

#ifdef GL_PROGRAM_OUTPUT
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::program_output;
#endif

#ifdef GL_PROGRAM_PIPELINE
const enum_value<
	GLenum,
	mp_list<oglplus::object_type>
> enum_values::program_pipeline;
#endif

#ifdef GL_PROGRAM_POINT_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::capability,oglplus::numeric_query>
> enum_values::program_point_size;
#endif

#ifdef GL_PROJECTION
const enum_value<
	GLenum,
	mp_list<oglplus::old_matrix_mode>
> enum_values::projection;
#endif

#ifdef GL_PROVOKING_VERTEX
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::provoking_vertex;
#endif

#ifdef GL_QUAD_STRIP
const enum_value<
	GLenum,
	mp_list<oglplus::old_primitive_type>
> enum_values::quad_strip;
#endif

#ifdef GL_QUADRATIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::quadratic_curve_to_nv;
#endif

#ifdef GL_QUADS
const enum_value<
	GLenum,
	mp_list<oglplus::old_primitive_type,oglplus::tess_gen_primitive_type>
> enum_values::quads;
#endif

#ifdef GL_QUERY
const enum_value<
	GLenum,
	mp_list<oglplus::object_type>
> enum_values::query;
#endif

#ifdef GL_QUERY_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_target>
> enum_values::query_buffer;
#endif

#ifdef GL_QUERY_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::query_buffer_binding;
#endif

#ifdef GL_QUERY_BY_REGION_NO_WAIT
const enum_value<
	GLenum,
	mp_list<oglplus::conditional_render_mode>
> enum_values::query_by_region_no_wait;
#endif

#ifdef GL_QUERY_BY_REGION_NO_WAIT_INVERTED
const enum_value<
	GLenum,
	mp_list<oglplus::conditional_render_mode>
> enum_values::query_by_region_no_wait_inverted;
#endif

#ifdef GL_QUERY_BY_REGION_WAIT
const enum_value<
	GLenum,
	mp_list<oglplus::conditional_render_mode>
> enum_values::query_by_region_wait;
#endif

#ifdef GL_QUERY_BY_REGION_WAIT_INVERTED
const enum_value<
	GLenum,
	mp_list<oglplus::conditional_render_mode>
> enum_values::query_by_region_wait_inverted;
#endif

#ifdef GL_QUERY_NO_WAIT
const enum_value<
	GLenum,
	mp_list<oglplus::conditional_render_mode>
> enum_values::query_no_wait;
#endif

#ifdef GL_QUERY_NO_WAIT_INVERTED
const enum_value<
	GLenum,
	mp_list<oglplus::conditional_render_mode>
> enum_values::query_no_wait_inverted;
#endif

#ifdef GL_QUERY_RESULT
const enum_value<
	GLenum,
	mp_list<oglplus::query_parameter>
> enum_values::query_result;
#endif

#ifdef GL_QUERY_RESULT_AVAILABLE
const enum_value<
	GLenum,
	mp_list<oglplus::query_parameter>
> enum_values::query_result_available;
#endif

#ifdef GL_QUERY_WAIT
const enum_value<
	GLenum,
	mp_list<oglplus::conditional_render_mode>
> enum_values::query_wait;
#endif

#ifdef GL_QUERY_WAIT_INVERTED
const enum_value<
	GLenum,
	mp_list<oglplus::conditional_render_mode>
> enum_values::query_wait_inverted;
#endif

#ifdef GL_R11F_G11F_B10F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r11f_g11f_b10f;
#endif

#ifdef GL_R16
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r16;
#endif

#ifdef GL_R16_SNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r16_snorm;
#endif

#ifdef GL_R16F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r16f;
#endif

#ifdef GL_R16I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r16i;
#endif

#ifdef GL_R16UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r16ui;
#endif

#ifdef GL_R32F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r32f;
#endif

#ifdef GL_R32I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r32i;
#endif

#ifdef GL_R32UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r32ui;
#endif

#ifdef GL_R3_G3_B2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::r3_g3_b2;
#endif

#ifdef GL_R8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r8;
#endif

#ifdef GL_R8_SNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r8_snorm;
#endif

#ifdef GL_R8I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r8i;
#endif

#ifdef GL_R8UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::r8ui;
#endif

#ifdef GL_RASTERIZER_DISCARD
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::rasterizer_discard;
#endif

#ifdef GL_READ_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::read_buffer;
#endif

#ifdef GL_READ_FRAMEBUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_target>
> enum_values::read_framebuffer;
#endif

#ifdef GL_READ_ONLY
const enum_value<
	GLenum,
	mp_list<oglplus::access_specifier>
> enum_values::read_only;
#endif

#ifdef GL_READ_WRITE
const enum_value<
	GLenum,
	mp_list<oglplus::access_specifier>
> enum_values::read_write;
#endif

#ifdef GL_RECT_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::rect_nv;
#endif

#ifdef GL_RED
const enum_value<
	GLenum,
	mp_list<oglplus::texture_swizzle_mode,oglplus::pixel_data_format,oglplus::pixel_data_internal_format>
> enum_values::red;
#endif

#ifdef GL_RED_INTEGER
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::red_integer;
#endif

#ifdef GL_REFERENCED_BY_COMPUTE_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::referenced_by_compute_shader;
#endif

#ifdef GL_REFERENCED_BY_FRAGMENT_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::referenced_by_fragment_shader;
#endif

#ifdef GL_REFERENCED_BY_GEOMETRY_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::referenced_by_geometry_shader;
#endif

#ifdef GL_REFERENCED_BY_TESS_CONTROL_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::referenced_by_tess_control_shader;
#endif

#ifdef GL_REFERENCED_BY_TESS_EVALUATION_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::referenced_by_tess_evaluation_shader;
#endif

#ifdef GL_REFERENCED_BY_VERTEX_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::referenced_by_vertex_shader;
#endif

#ifdef GL_RELATIVE_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_arc_to_nv;
#endif

#ifdef GL_RELATIVE_CUBIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_cubic_curve_to_nv;
#endif

#ifdef GL_RELATIVE_HORIZONTAL_LINE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_horizontal_line_to_nv;
#endif

#ifdef GL_RELATIVE_LARGE_CCW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_large_ccw_arc_to_nv;
#endif

#ifdef GL_RELATIVE_LARGE_CW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_large_cw_arc_to_nv;
#endif

#ifdef GL_RELATIVE_LINE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_line_to_nv;
#endif

#ifdef GL_RELATIVE_MOVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_move_to_nv;
#endif

#ifdef GL_RELATIVE_QUADRATIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_quadratic_curve_to_nv;
#endif

#ifdef GL_RELATIVE_SMALL_CCW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_small_ccw_arc_to_nv;
#endif

#ifdef GL_RELATIVE_SMALL_CW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_small_cw_arc_to_nv;
#endif

#ifdef GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_smooth_cubic_curve_to_nv;
#endif

#ifdef GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_smooth_quadratic_curve_to_nv;
#endif

#ifdef GL_RELATIVE_VERTICAL_LINE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::relative_vertical_line_to_nv;
#endif

#ifdef GL_RENDERBUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::object_type,oglplus::renderbuffer_target>
> enum_values::renderbuffer;
#endif

#ifdef GL_RENDERBUFFER_ALPHA_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_alpha_size;
#endif

#ifdef GL_RENDERBUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::renderbuffer_binding;
#endif

#ifdef GL_RENDERBUFFER_BLUE_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_blue_size;
#endif

#ifdef GL_RENDERBUFFER_DEPTH_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_depth_size;
#endif

#ifdef GL_RENDERBUFFER_GREEN_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_green_size;
#endif

#ifdef GL_RENDERBUFFER_HEIGHT
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_height;
#endif

#ifdef GL_RENDERBUFFER_INTERNAL_FORMAT
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_internal_format;
#endif

#ifdef GL_RENDERBUFFER_RED_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_red_size;
#endif

#ifdef GL_RENDERBUFFER_SAMPLES
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_samples;
#endif

#ifdef GL_RENDERBUFFER_STENCIL_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_stencil_size;
#endif

#ifdef GL_RENDERBUFFER_WIDTH
const enum_value<
	GLenum,
	mp_list<oglplus::renderbuffer_parameter>
> enum_values::renderbuffer_width;
#endif

#ifdef GL_RENDERER
const enum_value<
	GLenum,
	mp_list<oglplus::string_query>
> enum_values::renderer;
#endif

#ifdef GL_REPEAT
const enum_value<
	GLenum,
	mp_list<oglplus::texture_wrap_mode>
> enum_values::repeat;
#endif

#ifdef GL_REPLACE
const enum_value<
	GLenum,
	mp_list<oglplus::stencil_operation>
> enum_values::replace;
#endif

#ifdef GL_RESTART_PATH_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::restart_path_nv;
#endif

#ifdef GL_RG
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format,oglplus::pixel_data_internal_format>
> enum_values::rg;
#endif

#ifdef GL_RG16
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg16;
#endif

#ifdef GL_RG16_SNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg16_snorm;
#endif

#ifdef GL_RG16F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg16f;
#endif

#ifdef GL_RG16I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg16i;
#endif

#ifdef GL_RG16UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg16ui;
#endif

#ifdef GL_RG32F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg32f;
#endif

#ifdef GL_RG32I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg32i;
#endif

#ifdef GL_RG32UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg32ui;
#endif

#ifdef GL_RG8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg8;
#endif

#ifdef GL_RG8_SNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg8_snorm;
#endif

#ifdef GL_RG8I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg8i;
#endif

#ifdef GL_RG8UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rg8ui;
#endif

#ifdef GL_RG_INTEGER
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::rg_integer;
#endif

#ifdef GL_RGB
const enum_value<
	GLenum,
	mp_list<oglplus::path_color_format_nv,oglplus::pixel_data_format,oglplus::pixel_data_internal_format>
> enum_values::rgb;
#endif

#ifdef GL_RGB10
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb10;
#endif

#ifdef GL_RGB10_A2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgb10_a2;
#endif

#ifdef GL_RGB10_A2UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgb10_a2ui;
#endif

#ifdef GL_RGB12
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb12;
#endif

#ifdef GL_RGB16
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb16;
#endif

#ifdef GL_RGB16_SNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb16_snorm;
#endif

#ifdef GL_RGB16F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb16f;
#endif

#ifdef GL_RGB16I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb16i;
#endif

#ifdef GL_RGB16UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb16ui;
#endif

#ifdef GL_RGB32F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb32f;
#endif

#ifdef GL_RGB32I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb32i;
#endif

#ifdef GL_RGB32UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb32ui;
#endif

#ifdef GL_RGB4
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb4;
#endif

#ifdef GL_RGB5
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb5;
#endif

#ifdef GL_RGB5_A1
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb5_a1;
#endif

#ifdef GL_RGB8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb8;
#endif

#ifdef GL_RGB8_SNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb8_snorm;
#endif

#ifdef GL_RGB8I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb8i;
#endif

#ifdef GL_RGB8UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb8ui;
#endif

#ifdef GL_RGB9_E5
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgb9_e5;
#endif

#ifdef GL_RGB_INTEGER
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::rgb_integer;
#endif

#ifdef GL_RGBA
const enum_value<
	GLenum,
	mp_list<oglplus::path_color_format_nv,oglplus::pixel_data_format,oglplus::pixel_data_internal_format>
> enum_values::rgba;
#endif

#ifdef GL_RGBA12
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgba12;
#endif

#ifdef GL_RGBA16
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba16;
#endif

#ifdef GL_RGBA16_SNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba16_snorm;
#endif

#ifdef GL_RGBA16F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba16f;
#endif

#ifdef GL_RGBA16I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba16i;
#endif

#ifdef GL_RGBA16UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba16ui;
#endif

#ifdef GL_RGBA2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgba2;
#endif

#ifdef GL_RGBA32F
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba32f;
#endif

#ifdef GL_RGBA32I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba32i;
#endif

#ifdef GL_RGBA32UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba32ui;
#endif

#ifdef GL_RGBA4
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::rgba4;
#endif

#ifdef GL_RGBA8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba8;
#endif

#ifdef GL_RGBA8_SNORM
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba8_snorm;
#endif

#ifdef GL_RGBA8I
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba8i;
#endif

#ifdef GL_RGBA8UI
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format,oglplus::image_unit_format>
> enum_values::rgba8ui;
#endif

#ifdef GL_RGBA_INTEGER
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::rgba_integer;
#endif

#ifdef GL_RIGHT
const enum_value<
	GLenum,
	mp_list<oglplus::color_buffer>
> enum_values::right;
#endif

#ifdef GL_ROUND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_cap_style_nv,oglplus::path_join_style_nv>
> enum_values::round_nv;
#endif

#ifdef GL_SAMPLE_ALPHA_TO_COVERAGE
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::sample_alpha_to_coverage;
#endif

#ifdef GL_SAMPLE_ALPHA_TO_ONE
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::sample_alpha_to_one;
#endif

#ifdef GL_SAMPLE_BUFFERS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::sample_buffers;
#endif

#ifdef GL_SAMPLE_COVERAGE
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::sample_coverage;
#endif

#ifdef GL_SAMPLE_COVERAGE_INVERT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::sample_coverage_invert;
#endif

#ifdef GL_SAMPLE_COVERAGE_VALUE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::sample_coverage_value;
#endif

#ifdef GL_SAMPLE_MASK
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::sample_mask;
#endif

#ifdef GL_SAMPLE_SHADING
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::sample_shading;
#endif

#ifdef GL_SAMPLER
const enum_value<
	GLenum,
	mp_list<oglplus::object_type>
> enum_values::sampler;
#endif

#ifdef GL_SAMPLER_1D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_1d;
#endif

#ifdef GL_SAMPLER_1D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_1d_array;
#endif

#ifdef GL_SAMPLER_1D_ARRAY_SHADOW
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_1d_array_shadow;
#endif

#ifdef GL_SAMPLER_1D_SHADOW
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_1d_shadow;
#endif

#ifdef GL_SAMPLER_2D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_2d;
#endif

#ifdef GL_SAMPLER_2D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_2d_array;
#endif

#ifdef GL_SAMPLER_2D_ARRAY_SHADOW
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_2d_array_shadow;
#endif

#ifdef GL_SAMPLER_2D_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_2d_multisample;
#endif

#ifdef GL_SAMPLER_2D_MULTISAMPLE_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_2d_multisample_array;
#endif

#ifdef GL_SAMPLER_2D_RECT
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_2d_rect;
#endif

#ifdef GL_SAMPLER_2D_RECT_SHADOW
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_2d_rect_shadow;
#endif

#ifdef GL_SAMPLER_2D_SHADOW
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_2d_shadow;
#endif

#ifdef GL_SAMPLER_3D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_3d;
#endif

#ifdef GL_SAMPLER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::sampler_binding;
#endif

#ifdef GL_SAMPLER_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_buffer;
#endif

#ifdef GL_SAMPLER_CUBE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_cube;
#endif

#ifdef GL_SAMPLER_CUBE_MAP_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_cube_map_array;
#endif

#ifdef GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_cube_map_array_shadow;
#endif

#ifdef GL_SAMPLER_CUBE_SHADOW
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::sampler_cube_shadow;
#endif

#ifdef GL_SAMPLES
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::samples;
#endif

#ifdef GL_SAMPLES_PASSED
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::samples_passed;
#endif

#ifdef GL_SCISSOR_BOX
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::scissor_box;
#endif

#ifdef GL_SCISSOR_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::scissor_command_nv;
#endif

#ifdef GL_SCISSOR_TEST
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::scissor_test;
#endif

#ifdef GL_SCREEN_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::screen_khr;
#endif

#ifdef GL_SECONDARY_COLOR_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::secondary_color_array_address_nv;
#endif

#ifdef GL_SECONDARY_COLOR_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_color_nv>
> enum_values::secondary_color_nv;
#endif

#ifdef GL_SEPARATE_ATTRIBS
const enum_value<
	GLenum,
	mp_list<oglplus::transform_feedback_mode>
> enum_values::separate_attribs;
#endif

#ifdef GL_SET
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::set;
#endif

#ifdef GL_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::object_type>
> enum_values::shader;
#endif

#ifdef GL_SHADER_COMPILER
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::shader_compiler;
#endif

#ifdef GL_SHADER_GLOBAL_ACCESS_BARRIER_BIT_NV
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::shader_global_access_barrier_bit_nv;
#endif

#ifdef GL_SHADER_IMAGE_ACCESS_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::shader_image_access_barrier_bit;
#endif

#ifdef GL_SHADER_INCLUDE_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::named_string_type>
> enum_values::shader_include;
#endif

#ifdef GL_SHADER_SOURCE_LENGTH
const enum_value<
	GLenum,
	mp_list<oglplus::shader_parameter>
> enum_values::shader_source_length;
#endif

#ifdef GL_SHADER_STORAGE_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::shader_storage_barrier_bit;
#endif

#ifdef GL_SHADER_STORAGE_BLOCK
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::shader_storage_block;
#endif

#ifdef GL_SHADER_STORAGE_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_indexed_target,oglplus::buffer_target>
> enum_values::shader_storage_buffer;
#endif

#ifdef GL_SHADER_STORAGE_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::shader_storage_buffer_binding;
#endif

#ifdef GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::shader_storage_buffer_offset_alignment;
#endif

#ifdef GL_SHADER_STORAGE_BUFFER_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::shader_storage_buffer_size;
#endif

#ifdef GL_SHADER_STORAGE_BUFFER_START
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::shader_storage_buffer_start;
#endif

#ifdef GL_SHADER_TYPE
const enum_value<
	GLenum,
	mp_list<oglplus::shader_parameter>
> enum_values::shader_type;
#endif

#ifdef GL_SHADING_LANGUAGE_VERSION
const enum_value<
	GLenum,
	mp_list<oglplus::string_query>
> enum_values::shading_language_version;
#endif

#ifdef GL_SHORT
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type,oglplus::data_type>
> enum_values::short_;
#endif

#ifdef GL_SIGNALED
const enum_value<
	GLenum,
	mp_list<oglplus::sync_status>
> enum_values::signaled;
#endif

#ifdef GL_SKIP_MISSING_GLYPH_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_missing_glyph_nv>
> enum_values::skip_missing_glyph_nv;
#endif

#ifdef GL_SMALL_CCW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::small_ccw_arc_to_nv;
#endif

#ifdef GL_SMALL_CW_ARC_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::small_cw_arc_to_nv;
#endif

#ifdef GL_SMOOTH_CUBIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::smooth_cubic_curve_to_nv;
#endif

#ifdef GL_SMOOTH_LINE_WIDTH_GRANULARITY
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::smooth_line_width_granularity;
#endif

#ifdef GL_SMOOTH_LINE_WIDTH_RANGE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::smooth_line_width_range;
#endif

#ifdef GL_SMOOTH_QUADRATIC_CURVE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::smooth_quadratic_curve_to_nv;
#endif

#ifdef GL_SOFTLIGHT_KHR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_equation_advanced>
> enum_values::softlight_khr;
#endif

#ifdef GL_SPARSE_STORAGE_BIT_ARB
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_storage_bits>
> enum_values::sparse_storage_bit;
#endif

#ifdef GL_SQUARE_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_cap_style_nv>
> enum_values::square_nv;
#endif

#ifdef GL_SRC1_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::src1_alpha;
#endif

#ifdef GL_SRC1_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::src1_color;
#endif

#ifdef GL_SRC_ALPHA
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::src_alpha;
#endif

#ifdef GL_SRC_ALPHA_SATURATE
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::src_alpha_saturate;
#endif

#ifdef GL_SRC_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function>
> enum_values::src_color;
#endif

#ifdef GL_SRGB8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::srgb8;
#endif

#ifdef GL_SRGB8_ALPHA8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::srgb8_alpha8;
#endif

#ifdef GL_STACK_OVERFLOW
const enum_value<
	GLenum,
	mp_list<oglplus::error_code>
> enum_values::stack_overflow;
#endif

#ifdef GL_STACK_UNDERFLOW
const enum_value<
	GLenum,
	mp_list<oglplus::error_code>
> enum_values::stack_underflow;
#endif

#ifdef GL_STANDARD_FONT_NAME_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_font_target_nv>
> enum_values::standard_font_name_nv;
#endif

#ifdef GL_STATIC_COPY
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_usage>
> enum_values::static_copy;
#endif

#ifdef GL_STATIC_DRAW
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_usage>
> enum_values::static_draw;
#endif

#ifdef GL_STATIC_READ
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_usage>
> enum_values::static_read;
#endif

#ifdef GL_STENCIL
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_buffer>
> enum_values::stencil;
#endif

#ifdef GL_STENCIL_ATTACHMENT
const enum_value<
	GLenum,
	mp_list<oglplus::framebuffer_other_attachment>
> enum_values::stencil_attachment;
#endif

#ifdef GL_STENCIL_BACK_FAIL
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_back_fail;
#endif

#ifdef GL_STENCIL_BACK_FUNC
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_back_func;
#endif

#ifdef GL_STENCIL_BACK_PASS_DEPTH_FAIL
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_back_pass_depth_fail;
#endif

#ifdef GL_STENCIL_BACK_PASS_DEPTH_PASS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_back_pass_depth_pass;
#endif

#ifdef GL_STENCIL_BACK_REF
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_back_ref;
#endif

#ifdef GL_STENCIL_BACK_VALUE_MASK
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_back_value_mask;
#endif

#ifdef GL_STENCIL_BACK_WRITEMASK
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_back_writemask;
#endif

#ifdef GL_STENCIL_BUFFER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::buffer_select_bits>
> enum_values::stencil_buffer_bit;
#endif

#ifdef GL_STENCIL_CLEAR_VALUE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_clear_value;
#endif

#ifdef GL_STENCIL_FAIL
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_fail;
#endif

#ifdef GL_STENCIL_FUNC
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_func;
#endif

#ifdef GL_STENCIL_INDEX
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_format>
> enum_values::stencil_index;
#endif

#ifdef GL_STENCIL_INDEX8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_internal_format>
> enum_values::stencil_index8;
#endif

#ifdef GL_STENCIL_PASS_DEPTH_FAIL
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_pass_depth_fail;
#endif

#ifdef GL_STENCIL_PASS_DEPTH_PASS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_pass_depth_pass;
#endif

#ifdef GL_STENCIL_REF
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_ref;
#endif

#ifdef GL_STENCIL_REF_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::stencil_ref_command_nv;
#endif

#ifdef GL_STENCIL_TEST
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::stencil_test;
#endif

#ifdef GL_STENCIL_VALUE_MASK
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_value_mask;
#endif

#ifdef GL_STENCIL_WRITEMASK
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stencil_writemask;
#endif

#ifdef GL_STEREO
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::stereo;
#endif

#ifdef GL_STREAM_COPY
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_usage>
> enum_values::stream_copy;
#endif

#ifdef GL_STREAM_DRAW
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_usage>
> enum_values::stream_draw;
#endif

#ifdef GL_STREAM_RASTERIZATION_AMD
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::stream_rasterization;
#endif

#ifdef GL_STREAM_READ
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_usage>
> enum_values::stream_read;
#endif

#ifdef GL_SUBPIXEL_BITS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::subpixel_bits;
#endif

#ifdef GL_SYNC_FENCE
const enum_value<
	GLenum,
	mp_list<oglplus::sync_type>
> enum_values::sync_fence;
#endif

#ifdef GL_SYNC_GPU_COMMANDS_COMPLETE
const enum_value<
	GLenum,
	mp_list<oglplus::sync_condition>
> enum_values::sync_gpu_commands_complete;
#endif

#ifdef GL_SYSTEM_FONT_NAME_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_font_target_nv>
> enum_values::system_font_name_nv;
#endif

#ifdef GL_TABLE_TOO_LARGE
const enum_value<
	GLenum,
	mp_list<oglplus::error_code>
> enum_values::table_too_large;
#endif

#ifdef GL_TERMINATE_SEQUENCE_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::terminate_sequence_command_nv;
#endif

#ifdef GL_TESS_CONTROL_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::shader_type,oglplus::program_pipeline_parameter>
> enum_values::tess_control_shader;
#endif

#ifdef GL_TESS_CONTROL_SHADER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::program_pipeline_stage>
> enum_values::tess_control_shader_bit;
#endif

#ifdef GL_TESS_CONTROL_SHADER_PATCHES_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::tess_control_shader_patches;
#endif

#ifdef GL_TESS_CONTROL_SUBROUTINE
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::tess_control_subroutine;
#endif

#ifdef GL_TESS_CONTROL_SUBROUTINE_UNIFORM
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::tess_control_subroutine_uniform;
#endif

#ifdef GL_TESS_EVALUATION_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::shader_type,oglplus::program_pipeline_parameter>
> enum_values::tess_evaluation_shader;
#endif

#ifdef GL_TESS_EVALUATION_SHADER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::program_pipeline_stage>
> enum_values::tess_evaluation_shader_bit;
#endif

#ifdef GL_TESS_EVALUATION_SHADER_INVOCATIONS_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::tess_evaluation_shader_invocations;
#endif

#ifdef GL_TESS_EVALUATION_SUBROUTINE
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::tess_evaluation_subroutine;
#endif

#ifdef GL_TESS_EVALUATION_SUBROUTINE_UNIFORM
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::tess_evaluation_subroutine_uniform;
#endif

#ifdef GL_TEXTURE
const enum_value<
	GLenum,
	mp_list<oglplus::old_matrix_mode,oglplus::object_type>
> enum_values::texture;
#endif

#ifdef GL_TEXTURE0
const enum_value<
	GLenum,
	mp_list<oglplus::indexed_value_base>
> enum_values::texture0;
#endif

#ifdef GL_TEXTURE_1D
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_1d;
#endif

#ifdef GL_TEXTURE_1D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_1d_array;
#endif

#ifdef GL_TEXTURE_2D
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_2d;
#endif

#ifdef GL_TEXTURE_2D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_2d_array;
#endif

#ifdef GL_TEXTURE_2D_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_2d_multisample;
#endif

#ifdef GL_TEXTURE_2D_MULTISAMPLE_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_2d_multisample_array;
#endif

#ifdef GL_TEXTURE_3D
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_3d;
#endif

#ifdef GL_TEXTURE_BASE_LEVEL
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::texture_base_level;
#endif

#ifdef GL_TEXTURE_BINDING_1D
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_1d;
#endif

#ifdef GL_TEXTURE_BINDING_1D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_1d_array;
#endif

#ifdef GL_TEXTURE_BINDING_2D
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_2d;
#endif

#ifdef GL_TEXTURE_BINDING_2D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_2d_array;
#endif

#ifdef GL_TEXTURE_BINDING_2D_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_2d_multisample;
#endif

#ifdef GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_2d_multisample_array;
#endif

#ifdef GL_TEXTURE_BINDING_3D
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_3d;
#endif

#ifdef GL_TEXTURE_BINDING_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_buffer;
#endif

#ifdef GL_TEXTURE_BINDING_CUBE_MAP
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_cube_map;
#endif

#ifdef GL_TEXTURE_BINDING_CUBE_MAP_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_cube_map_array;
#endif

#ifdef GL_TEXTURE_BINDING_RECTANGLE
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_binding_rectangle;
#endif

#ifdef GL_TEXTURE_BORDER_COLOR
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter>
> enum_values::texture_border_color;
#endif

#ifdef GL_TEXTURE_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target,oglplus::buffer_target>
> enum_values::texture_buffer;
#endif

#ifdef GL_TEXTURE_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::texture_buffer_binding;
#endif

#ifdef GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::texture_buffer_offset_alignment;
#endif

#ifdef GL_TEXTURE_COMPARE_FUNC
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter>
> enum_values::texture_compare_func;
#endif

#ifdef GL_TEXTURE_COMPARE_MODE
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter>
> enum_values::texture_compare_mode;
#endif

#ifdef GL_TEXTURE_COMPRESSION_HINT
const enum_value<
	GLenum,
	mp_list<oglplus::hint_target,oglplus::numeric_query>
> enum_values::texture_compression_hint;
#endif

#ifdef GL_TEXTURE_COORD_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::texture_coord_array_address_nv;
#endif

#ifdef GL_TEXTURE_CUBE_MAP
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_cube_map;
#endif

#ifdef GL_TEXTURE_CUBE_MAP_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_cube_map_array;
#endif

#ifdef GL_TEXTURE_CUBE_MAP_NEGATIVE_X
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_cube_map_negative_x;
#endif

#ifdef GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_cube_map_negative_y;
#endif

#ifdef GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_cube_map_negative_z;
#endif

#ifdef GL_TEXTURE_CUBE_MAP_POSITIVE_X
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_cube_map_positive_x;
#endif

#ifdef GL_TEXTURE_CUBE_MAP_POSITIVE_Y
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_cube_map_positive_y;
#endif

#ifdef GL_TEXTURE_CUBE_MAP_POSITIVE_Z
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_cube_map_positive_z;
#endif

#ifdef GL_TEXTURE_CUBE_MAP_SEAMLESS
const enum_value<
	GLenum,
	mp_list<oglplus::capability>
> enum_values::texture_cube_map_seamless;
#endif

#ifdef GL_TEXTURE_FETCH_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::texture_fetch_barrier_bit;
#endif

#ifdef GL_TEXTURE_IMMUTABLE_FORMAT
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::texture_immutable_format;
#endif

#ifdef GL_TEXTURE_IMMUTABLE_LEVELS
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::texture_immutable_levels;
#endif

#ifdef GL_TEXTURE_LOD_BIAS
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter>
> enum_values::texture_lod_bias;
#endif

#ifdef GL_TEXTURE_MAG_FILTER
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter>
> enum_values::texture_mag_filter;
#endif

#ifdef GL_TEXTURE_MAX_LEVEL
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::texture_max_level;
#endif

#ifdef GL_TEXTURE_MAX_LOD
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter>
> enum_values::texture_max_lod;
#endif

#ifdef GL_TEXTURE_MIN_FILTER
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter>
> enum_values::texture_min_filter;
#endif

#ifdef GL_TEXTURE_MIN_LOD
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter>
> enum_values::texture_min_lod;
#endif

#ifdef GL_TEXTURE_RECTANGLE
const enum_value<
	GLenum,
	mp_list<oglplus::texture_target>
> enum_values::texture_rectangle;
#endif

#ifdef GL_TEXTURE_SWIZZLE_A
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::texture_swizzle_coord>
> enum_values::texture_swizzle_a;
#endif

#ifdef GL_TEXTURE_SWIZZLE_B
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::texture_swizzle_coord>
> enum_values::texture_swizzle_b;
#endif

#ifdef GL_TEXTURE_SWIZZLE_G
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::texture_swizzle_coord>
> enum_values::texture_swizzle_g;
#endif

#ifdef GL_TEXTURE_SWIZZLE_R
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::texture_swizzle_coord>
> enum_values::texture_swizzle_r;
#endif

#ifdef GL_TEXTURE_SWIZZLE_RGBA
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::texture_swizzle_coord>
> enum_values::texture_swizzle_rgba;
#endif

#ifdef GL_TEXTURE_TARGET
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::texture_target;
#endif

#ifdef GL_TEXTURE_UPDATE_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::texture_update_barrier_bit;
#endif

#ifdef GL_TEXTURE_VIEW_MIN_LAYER
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::texture_view_min_layer;
#endif

#ifdef GL_TEXTURE_VIEW_MIN_LEVEL
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::texture_view_min_level;
#endif

#ifdef GL_TEXTURE_VIEW_NUM_LAYERS
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::texture_view_num_layers;
#endif

#ifdef GL_TEXTURE_VIEW_NUM_LEVELS
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter>
> enum_values::texture_view_num_levels;
#endif

#ifdef GL_TEXTURE_WRAP_R
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter,oglplus::texture_wrap_coord>
> enum_values::texture_wrap_r;
#endif

#ifdef GL_TEXTURE_WRAP_S
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter,oglplus::texture_wrap_coord>
> enum_values::texture_wrap_s;
#endif

#ifdef GL_TEXTURE_WRAP_T
const enum_value<
	GLenum,
	mp_list<oglplus::texture_parameter,oglplus::sampler_parameter,oglplus::texture_wrap_coord>
> enum_values::texture_wrap_t;
#endif

#ifdef GL_TIME_ELAPSED
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::time_elapsed;
#endif

#ifdef GL_TIMEOUT_EXPIRED
const enum_value<
	GLenum,
	mp_list<oglplus::sync_wait_result>
> enum_values::timeout_expired;
#endif

#ifdef GL_TIMESTAMP
const enum_value<
	GLenum,
	mp_list<oglplus::query_target,oglplus::numeric_query>
> enum_values::timestamp;
#endif

#ifdef GL_TOP_LEVEL_ARRAY_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::top_level_array_size;
#endif

#ifdef GL_TOP_LEVEL_ARRAY_STRIDE
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::top_level_array_stride;
#endif

#ifdef GL_TRANSFORM_FEEDBACK
const enum_value<
	GLenum,
	mp_list<oglplus::transform_feedback_target,oglplus::object_type>
> enum_values::transform_feedback;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_ACTIVE
const enum_value<
	GLenum,
	mp_list<oglplus::transform_feedback_parameter>
> enum_values::transform_feedback_active;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::transform_feedback_barrier_bit;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::transform_feedback_binding;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_indexed_target,oglplus::buffer_target>
> enum_values::transform_feedback_buffer;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::transform_feedback_parameter,oglplus::binding_query>
> enum_values::transform_feedback_buffer_binding;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_INDEX
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::transform_feedback_buffer_index;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::transform_feedback_parameter,oglplus::numeric_query>
> enum_values::transform_feedback_buffer_size;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_START
const enum_value<
	GLenum,
	mp_list<oglplus::transform_feedback_parameter,oglplus::numeric_query>
> enum_values::transform_feedback_buffer_start;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE
const enum_value<
	GLenum,
	mp_list<oglplus::program_resource_property>
> enum_values::transform_feedback_buffer_stride;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_OVERFLOW_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::transform_feedback_overflow;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_PAUSED
const enum_value<
	GLenum,
	mp_list<oglplus::transform_feedback_parameter>
> enum_values::transform_feedback_paused;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::transform_feedback_primitives_written;
#endif

#ifdef GL_TRANSFORM_FEEDBACK_STREAM_OVERFLOW_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::transform_feedback_stream_overflow;
#endif

#ifdef GL_TRANSFORM_FEEDEBACK_VARYING
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::transform_feedeback_varying;
#endif

#ifdef GL_TRANSLATE_2D_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_transform_type_nv>
> enum_values::translate_2d_nv;
#endif

#ifdef GL_TRANSLATE_3D_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_transform_type_nv>
> enum_values::translate_3d_nv;
#endif

#ifdef GL_TRANSLATE_X_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_transform_type_nv>
> enum_values::translate_x_nv;
#endif

#ifdef GL_TRANSLATE_Y_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_transform_type_nv>
> enum_values::translate_y_nv;
#endif

#ifdef GL_TRANSPOSE_AFFINE_2D_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_transform_type_nv>
> enum_values::transpose_affine_2d_nv;
#endif

#ifdef GL_TRANSPOSE_AFFINE_3D_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_transform_type_nv>
> enum_values::transpose_affine_3d_nv;
#endif

#ifdef GL_TRIANGLE_FAN
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type,oglplus::old_primitive_type>
> enum_values::triangle_fan;
#endif

#ifdef GL_TRIANGLE_STRIP
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type,oglplus::old_primitive_type>
> enum_values::triangle_strip;
#endif

#ifdef GL_TRIANGLE_STRIP_ADJACENCY
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type>
> enum_values::triangle_strip_adjacency;
#endif

#ifdef GL_TRIANGLES
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type,oglplus::old_primitive_type,oglplus::transform_feedback_primitive_type,oglplus::tess_gen_primitive_type>
> enum_values::triangles;
#endif

#ifdef GL_TRIANGLES_ADJACENCY
const enum_value<
	GLenum,
	mp_list<oglplus::primitive_type>
> enum_values::triangles_adjacency;
#endif

#ifdef GL_TRIANGULAR_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_cap_style_nv>
> enum_values::triangular_nv;
#endif

#ifdef GL_TRUE
const enum_value<
	GLboolean,
	mp_list<oglplus::true_false>
> enum_values::true_;
#endif

#ifdef GL_UNIFORM
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::uniform;
#endif

#ifdef GL_UNIFORM_ADDRESS_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::uniform_address_command_nv;
#endif

#ifdef GL_UNIFORM_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::uniform_barrier_bit;
#endif

#ifdef GL_UNIFORM_BLOCK
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::uniform_block;
#endif

#ifdef GL_UNIFORM_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::buffer_indexed_target,oglplus::buffer_target>
> enum_values::uniform_buffer;
#endif

#ifdef GL_UNIFORM_BUFFER_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::uniform_buffer_address_nv;
#endif

#ifdef GL_UNIFORM_BUFFER_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::uniform_buffer_binding;
#endif

#ifdef GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::uniform_buffer_offset_alignment;
#endif

#ifdef GL_UNIFORM_BUFFER_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::uniform_buffer_size;
#endif

#ifdef GL_UNIFORM_BUFFER_START
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::uniform_buffer_start;
#endif

#ifdef GL_UNKNOWN_CONTEXT_RESET
const enum_value<
	GLenum,
	mp_list<oglplus::graphics_reset_status>
> enum_values::unknown_context_reset;
#endif

#ifdef GL_UNPACK_ALIGNMENT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::unpack_alignment;
#endif

#ifdef GL_UNPACK_COMPRESSED_BLOCK_DEPTH
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_parameter>
> enum_values::unpack_compressed_block_depth;
#endif

#ifdef GL_UNPACK_COMPRESSED_BLOCK_HEIGHT
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_parameter>
> enum_values::unpack_compressed_block_height;
#endif

#ifdef GL_UNPACK_COMPRESSED_BLOCK_SIZE
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_parameter>
> enum_values::unpack_compressed_block_size;
#endif

#ifdef GL_UNPACK_COMPRESSED_BLOCK_WIDTH
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_parameter>
> enum_values::unpack_compressed_block_width;
#endif

#ifdef GL_UNPACK_IMAGE_HEIGHT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::unpack_image_height;
#endif

#ifdef GL_UNPACK_LSB_FIRST
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::unpack_lsb_first;
#endif

#ifdef GL_UNPACK_ROW_LENGTH
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::unpack_row_length;
#endif

#ifdef GL_UNPACK_SKIP_IMAGES
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::unpack_skip_images;
#endif

#ifdef GL_UNPACK_SKIP_PIXELS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::unpack_skip_pixels;
#endif

#ifdef GL_UNPACK_SKIP_ROWS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::unpack_skip_rows;
#endif

#ifdef GL_UNPACK_SWAP_BYTES
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query,oglplus::pixel_parameter>
> enum_values::unpack_swap_bytes;
#endif

#ifdef GL_UNSIGNALED
const enum_value<
	GLenum,
	mp_list<oglplus::sync_status>
> enum_values::unsignaled;
#endif

#ifdef GL_UNSIGNED_BYTE
const enum_value<
	GLenum,
	mp_list<oglplus::index_type,oglplus::pixel_data_type,oglplus::data_type>
> enum_values::unsigned_byte;
#endif

#ifdef GL_UNSIGNED_BYTE_2_3_3_REV
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_byte_2_3_3_rev;
#endif

#ifdef GL_UNSIGNED_BYTE_3_3_2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_byte_3_3_2;
#endif

#ifdef GL_UNSIGNED_INT
const enum_value<
	GLenum,
	mp_list<oglplus::index_type,oglplus::sl_data_type,oglplus::pixel_data_type,oglplus::data_type>
> enum_values::unsigned_int;
#endif

#ifdef GL_UNSIGNED_INT_10_10_10_2
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_int_10_10_10_2;
#endif

#ifdef GL_UNSIGNED_INT_10F_11F_11F_REV
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_int_10f_11f_11f_rev;
#endif

#ifdef GL_UNSIGNED_INT_24_8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_int_24_8;
#endif

#ifdef GL_UNSIGNED_INT_2_10_10_10_REV
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_int_2_10_10_10_rev;
#endif

#ifdef GL_UNSIGNED_INT_5_9_9_9_REV
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_int_5_9_9_9_rev;
#endif

#ifdef GL_UNSIGNED_INT_8_8_8_8
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_int_8_8_8_8;
#endif

#ifdef GL_UNSIGNED_INT_8_8_8_8_REV
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_int_8_8_8_8_rev;
#endif

#ifdef GL_UNSIGNED_INT_ATOMIC_COUNTER
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_atomic_counter;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_1D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_1d;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_1D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_1d_array;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_2D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_2d;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_2D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_2d_array;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_2d_multisample;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_2d_multisample_array;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_2D_RECT
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_2d_rect;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_3D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_3d;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_buffer;
#endif

#ifdef GL_UNSIGNED_INT_IMAGE_CUBE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_image_cube;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_1D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_1d;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_1D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_1d_array;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_2D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_2d;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_2D_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_2d_array;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_2d_multisample;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_2d_multisample_array;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_2D_RECT
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_2d_rect;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_3D
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_3d;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_BUFFER
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_buffer;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_CUBE
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_cube;
#endif

#ifdef GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_sampler_cube_map_array;
#endif

#ifdef GL_UNSIGNED_INT_VEC2
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_vec2;
#endif

#ifdef GL_UNSIGNED_INT_VEC3
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_vec3;
#endif

#ifdef GL_UNSIGNED_INT_VEC4
const enum_value<
	GLenum,
	mp_list<oglplus::sl_data_type>
> enum_values::unsigned_int_vec4;
#endif

#ifdef GL_UNSIGNED_SHORT
const enum_value<
	GLenum,
	mp_list<oglplus::index_type,oglplus::pixel_data_type,oglplus::data_type>
> enum_values::unsigned_short;
#endif

#ifdef GL_UNSIGNED_SHORT_1_5_5_5_REV
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_short_1_5_5_5_rev;
#endif

#ifdef GL_UNSIGNED_SHORT_4_4_4_4
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_short_4_4_4_4;
#endif

#ifdef GL_UNSIGNED_SHORT_4_4_4_4_REV
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_short_4_4_4_4_rev;
#endif

#ifdef GL_UNSIGNED_SHORT_5_5_5_1
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_short_5_5_5_1;
#endif

#ifdef GL_UNSIGNED_SHORT_5_6_5
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_short_5_6_5;
#endif

#ifdef GL_UNSIGNED_SHORT_5_6_5_REV
const enum_value<
	GLenum,
	mp_list<oglplus::pixel_data_type>
> enum_values::unsigned_short_5_6_5_rev;
#endif

#ifdef GL_UPPER_LEFT
const enum_value<
	GLenum,
	mp_list<oglplus::clip_origin>
> enum_values::upper_left;
#endif

#ifdef GL_USE_MISSING_GLYPH_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_missing_glyph_nv>
> enum_values::use_missing_glyph_nv;
#endif

#ifdef GL_UTF16_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_text_encoding_nv>
> enum_values::utf16_nv;
#endif

#ifdef GL_UTF8_NV
const enum_value<
	GLenum,
	mp_list<oglplus::path_text_encoding_nv>
> enum_values::utf8_nv;
#endif

#ifdef GL_VALIDATE_STATUS
const enum_value<
	GLenum,
	mp_list<oglplus::program_parameter>
> enum_values::validate_status;
#endif

#ifdef GL_VENDOR
const enum_value<
	GLenum,
	mp_list<oglplus::string_query>
> enum_values::vendor;
#endif

#ifdef GL_VERSION
const enum_value<
	GLenum,
	mp_list<oglplus::string_query>
> enum_values::version;
#endif

#ifdef GL_VERTEX_ARRAY
const enum_value<
	GLenum,
	mp_list<oglplus::object_type>
> enum_values::vertex_array;
#endif

#ifdef GL_VERTEX_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::vertex_array_address_nv;
#endif

#ifdef GL_VERTEX_ARRAY_BINDING
const enum_value<
	GLenum,
	mp_list<oglplus::binding_query>
> enum_values::vertex_array_binding;
#endif

#ifdef GL_VERTEX_ATTRIB_ARRAY_ADDRESS_NV
const enum_value<
	GLenum,
	mp_list<oglplus::unified_array_address_nv>
> enum_values::vertex_attrib_array_address_nv;
#endif

#ifdef GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::memory_barrier_bits>
> enum_values::vertex_attrib_array_barrier_bit;
#endif

#ifdef GL_VERTEX_SHADER
const enum_value<
	GLenum,
	mp_list<oglplus::shader_type,oglplus::program_pipeline_parameter>
> enum_values::vertex_shader;
#endif

#ifdef GL_VERTEX_SHADER_BIT
const enum_value<
	GLbitfield,
	mp_list<oglplus::program_pipeline_stage>
> enum_values::vertex_shader_bit;
#endif

#ifdef GL_VERTEX_SHADER_INVOCATIONS_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::vertex_shader_invocations;
#endif

#ifdef GL_VERTEX_SUBROUTINE
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::vertex_subroutine;
#endif

#ifdef GL_VERTEX_SUBROUTINE_UNIFORM
const enum_value<
	GLenum,
	mp_list<oglplus::program_interface>
> enum_values::vertex_subroutine_uniform;
#endif

#ifdef GL_VERTICAL_LINE_TO_NV
const enum_value<
	GLubyte,
	mp_list<oglplus::path_command_nv>
> enum_values::vertical_line_to_nv;
#endif

#ifdef GL_VERTICES_SUBMITTED_ARB
const enum_value<
	GLenum,
	mp_list<oglplus::query_target>
> enum_values::vertices_submitted;
#endif

#ifdef GL_VIEWPORT
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::viewport;
#endif

#ifdef GL_VIEWPORT_BOUNDS_RANGE
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::viewport_bounds_range;
#endif

#ifdef GL_VIEWPORT_COMMAND_NV
const enum_value<
	GLenum,
	mp_list<oglplus::command_token_nv>
> enum_values::viewport_command_nv;
#endif

#ifdef GL_VIEWPORT_INDEX_PROVOKING_VERTEX
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::viewport_index_provoking_vertex;
#endif

#ifdef GL_VIEWPORT_SUBPIXEL_BITS
const enum_value<
	GLenum,
	mp_list<oglplus::numeric_query>
> enum_values::viewport_subpixel_bits;
#endif

#ifdef GL_WAIT_FAILED
const enum_value<
	GLenum,
	mp_list<oglplus::sync_wait_result>
> enum_values::wait_failed;
#endif

#ifdef GL_WRITE_ONLY
const enum_value<
	GLenum,
	mp_list<oglplus::access_specifier>
> enum_values::write_only;
#endif

#ifdef GL_XOR
const enum_value<
	GLenum,
	mp_list<oglplus::color_logic_operation>
> enum_values::xor_;
#endif

#ifdef GL_ZERO
const enum_value<
	GLenum,
	mp_list<oglplus::blend_function,oglplus::texture_swizzle_mode,oglplus::stencil_operation>
> enum_values::zero;
#endif

#ifdef GL_ZERO_TO_ONE
const enum_value<
	GLenum,
	mp_list<oglplus::clip_depth_mode>
> enum_values::zero_to_one;
#endif

} // namespace oglplus
