/**
 *  @file eagine/stdfix/optional.hpp
 *
 *  Copyright Matus Chochlik.
 *  Distributed under the Boost Software License, Version 1.0.
 *  See accompanying file LICENSE_1_0.txt or copy at
 *   http://www.boost.org/LICENSE_1_0.txt
 */
#ifndef EAGINE_STDFIX_OPTIONAL_1509260923_HPP
#define EAGINE_STDFIX_OPTIONAL_1509260923_HPP

#include <type_traits>
#include <stdexcept>
#include <cassert>

namespace std {

class bad_optional_access
 : public logic_error
{
public:
	bad_optional_access(void)
	 : logic_error("Bad optional access")
	{ }
};

struct nullopt_t {
	explicit constexpr
	nullopt_t(int)
	noexcept
	{ }
};

constexpr const nullopt_t nullopt{0};

template <typename T>
class optional
{
private:
	using _store_t = typename aligned_storage<
		sizeof(T),
		alignof(T)
	>::type;

	_store_t _store;
	bool _has_value;

	constexpr T& _get(void)
	noexcept { return *reinterpret_cast<T*>(&_store); }

	constexpr const T& _get(void) const
	noexcept { return *reinterpret_cast<const T*>(&_store); }

	void _move_in(optional<T>& that) {
		assert(!*this);
		assert(bool(that));
		new (&_store)T(move(that._get()));
		_has_value = true;
		that.reset();
	}

	void _destroy(void) {
		_get().T::~T();
	}

	template <typename U>
	using _enable_if_convertible = typename enable_if<
		is_convertible<U, T>::value
	>::type;
public:
	constexpr
	optional(nullopt_t)
	noexcept
	 : _has_value{false}
	{ }

	constexpr
	optional(void)
	noexcept
	 : optional{nullopt}
	{ }

	constexpr
	optional(const optional<T>& that)
	 : _has_value{false}
	{
		if(that.has_value()) {
			new (&_store)T(that._get());
			_has_value = true;
		}
	}

	template <typename U, typename = _enable_if_convertible<U>>
	constexpr explicit
	optional(const optional<U>& that)
	 : _has_value{false}
	{
		if(that.has_value()) {
			new (&_store)T(that.value());
			_has_value = true;
		}
	}

	constexpr
	optional(optional<T>&& temp)
	 : _has_value{false}
	{
		if(temp.has_value()) {
			new (&_store)T(move(temp._get()));
			_has_value = true;
			temp.reset();
		}
	}

	template <typename U, typename = _enable_if_convertible<U>>
	constexpr explicit
	optional(optional<U>&& temp)
	 : _has_value{false}
	{
		if(temp.has_value()) {
			new (&_store)T(move(temp.value()));
			_has_value = true;
			temp.reset();
		}
	}

	template <typename U = T, typename = _enable_if_convertible<U>>
	constexpr explicit
	optional(U&& init)
	 : _has_value{true}
	{
		new (&_store)T(forward<U>(init));
	}

	optional& operator = (nullopt_t) {
		reset();
		return *this;
	}

	optional& operator = (const optional<T>& that) {
		optional<T> temp{that};
		swap(temp);
		return *this;
	}

	template <typename U = T, typename = _enable_if_convertible<U>>
	optional& operator = (const optional<U>& that) {
		optional<T> temp{that};
		swap(temp);
		return *this;
	}

	optional& operator = (optional<T>&& temp) {
		swap(temp);
		return *this;
	}

	template <typename U = T, typename = _enable_if_convertible<U>>
	optional& operator = (optional<U>&& temp) {
		optional<T> that(std::move(temp));
		swap(that);
		return *this;
	}

	~optional(void) {
		reset();
	}

	void swap(optional<T>& that) {
		if(bool(*this) && bool(that)) {
			using std::swap;
			swap(_get(), that._get());
		} else if(!bool(*this) && bool(that)) {
			this->_move_in(that);
		} else if(bool(*this) && !bool(that)) {
			that._move_in(*this);
		}
	}

	template <typename ... Args>
	void emplace(Args&& ... args) {
		reset();
		new (&_store)T(forward<Args>(args)...);
	}

	void reset(void) {
		if(has_value()) {
			_destroy();
			_has_value = false;
		}
	}

	constexpr bool has_value(void) const { return _has_value; }
	constexpr operator bool (void) const { return has_value(); }
	constexpr bool operator !(void) const { return !has_value(); }

	constexpr T& value(void) {
		if(!has_value()) {
			throw bad_optional_access{};
		}
		return _get();
	}

	constexpr const T& value(void) const {
		if(!has_value()) {
			throw bad_optional_access{};
		}
		return _get();
	}

	constexpr T& operator * (void) { return value(); }
	constexpr const T& operator * (void) const { return value(); }

	constexpr T* operator -> (void) { return &value(); }
	constexpr const T* operator -> (void) const { return &value(); }

	template <typename U>
	constexpr T value_or(U&& fallback) const
	noexcept {
		return has_value()?
			_get():
			static_cast<T>(forward<U>(fallback));
	}

	friend constexpr
	bool operator == (const optional<T>& l, const optional<T>& r)
	noexcept {
		return	(bool(l) != bool(r))?false:
			(bool(l) == false)?true:
			(l._get() == r._get());
	}

	friend constexpr
	bool operator != (const optional<T>& l, const optional<T>& r)
	noexcept {
		return	(bool(l) != bool(r))?true:
			(bool(l) == false)?false:
			(l._get() != r._get());
	}

	friend constexpr
	bool operator <  (const optional<T>& l, const optional<T>& r)
	noexcept {
		return	(bool(r) == false)?false:
			(bool(l) == false)?true:
			(l._get() <  r._get());
	}

	friend constexpr
	bool operator <= (const optional<T>& l, const optional<T>& r)
	noexcept {
		return	(bool(l) == false)?true:
			(bool(r) == false)?false:
			(l._get() <= r._get());
	}

	friend constexpr
	bool operator >  (const optional<T>& l, const optional<T>& r)
	noexcept {
		return	(bool(l) == false)?false:
			(bool(r) == false)?true:
			(l._get() >  r._get());
	}

	friend constexpr
	bool operator >= (const optional<T>& l, const optional<T>& r)
	noexcept {
		return	(bool(r) == false)?true:
			(bool(l) == false)?false:
			(l._get() >= r._get());
	}

	friend constexpr
	bool operator == (const optional<T>& l, nullopt_t)
	noexcept { return !l; }

	friend constexpr
	bool operator == (nullopt_t, const optional<T>& r)
	noexcept { return !r; }

	friend constexpr
	bool operator != (const optional<T>& l, nullopt_t)
	noexcept { return bool(l); }

	friend constexpr
	bool operator != (nullopt_t, const optional<T>& r)
	noexcept { return bool(r); }

	friend constexpr
	bool operator <  (const optional<T>&  , nullopt_t)
	noexcept { return false; }

	friend constexpr
	bool operator <  (nullopt_t, const optional<T>& r)
	noexcept { return bool(r); }

	friend constexpr
	bool operator <= (const optional<T>& l, nullopt_t)
	noexcept { return !l; }

	friend constexpr
	bool operator <= (nullopt_t, const optional<T>&  )
	noexcept { return true; }

	friend constexpr
	bool operator >  (const optional<T>& l, nullopt_t)
	noexcept { return bool(l); }

	friend constexpr
	bool operator >  (nullopt_t, const optional<T>&  )
	noexcept { return false; }

	friend constexpr
	bool operator >= (const optional<T>&  , nullopt_t)
	noexcept { return true; }

	friend constexpr
	bool operator >= (nullopt_t, const optional<T>& r)
	noexcept { return !r; }
};

} // namespace std

#endif // include guard
